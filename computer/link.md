# 链接

链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。

**链接可以在编译时由静态编译器完成，也可以在加载时和运行时由动态链接器来完成**。

**链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定向确定每个符号的最终内存地址，并修改对那些目标的引用。**

# 编译器驱动程序
下面有一个简单的运行示例：

```
/* $begin main  文件main.c */
int sum(int *a, int n);
int array[2] = {1, 2};
int main() 
{
    int val = sum(array, 2);
    return val;
}
/* $end main */

/* $begin sum   文件sum.c*/
int sum(int *a, int n)
{
    int i, s = 0;
    for (i = 0; i < n; i++) { 
        s += a[i];
    }
    return s;
}        
/* $end sum */
```
大多数编译系统提供编译器驱动程序（compile driver），它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。如下，调用GCC驱动程序：linux> gcc -Og -o prog main.c sum.c

下图是静态链接的过程，链接器将可重定位目标文件组合起来，形成一个可执行的目标文件prog

![prog](/Users/liujie/Desktop/gitbook/image/computer/prog.png)

# 静态链接
像Linux LD程序这样的静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全的链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节组成，每一节都是一个连续的字节序列。（指令在一节中、初始化了的全局变量在另一节中，而未初始化的变量又在另外一节中）

为了构造可执行文件，链接器必须完成两个主要任务：
- 符号解析（symbol resolution）。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量。**符号解析的目的是将每个符号引用正好和一个符号定义关联起来。**
- 重定位（relocation）。编译器和汇编器生成从地址0开始的代码和数据节。**链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得他们指向这个内存位置**。

关于**链接器的本质事实**：**目标文件纯粹是字节块的集合**。这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含引导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。

# 目标文件
目标文件不同情况下具象的三种形式：
- 可重定位目标文件：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。
- 可执行目标文件：包含二进制代码和数据，其形式可以被直接复制到内存并执行。
- 共享目标文件：一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。

**编译器和汇编器生成可重定位目标文件（包括共享目标文件）；链接器生成可执行目标文件**。技术上来说，**目标模块就是一个字节序列，而一个目标文件就是一个以文件形式存放在磁盘中的目标模块**。

目标文件有特定的目标文件格式，windows使用可移植可执行（Portable Executable，PE）格式，MacOX-X使用Mach-O格式，而现代x86-64 Linux 和Unix系统使用可执行可链接格式（Executable and Linkable Format，ELF）。但他们基本概念都是类似的。
# 可重定位目标文件

下图展示了一个典型的ELF可重定位目标文件的格式。

![elffile](/Users/liujie/Desktop/gitbook/image/computer/elffile.png)

> 为什么未初始化的数据称为.bss？起源于“块存储开始（Block Storage Start）”的缩写，还有一种更好的区分.data和.bss之间的简单方法是把“bss”看成是“更好的节省空间（Better Save Space）”的缩写

# 符号和符号表
# 符号解析
# 与静态库链接
# 重定位
一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来。此时，链接器就知道他的输入目标模块中的代码节和数据节的确切大小。接下来就是重定位运行时真正的内存地址：
- 重定位节和符号定义。**链接器将所有相同类型的节合并为同一类型的新的聚合节**。例如，来自所有输入模块的.data节被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，**程序中的每条指令和全局变量都有唯一的运行时内存地址**了。
- 重定位节中的符号引用。**这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。** 要执行这一步，**链接器依赖于可重定位目标模块中称为重定位条目（relocation entry）的数据结构**。
## 汇编器生成的重定位条目
当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置，也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。

所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个**重定位条目**，**告诉链接器在将目标文件合并成可执行文件时如何修改这个引用**。代码的重定位条目放在.rel.text中，已初始化数据的重定位条目放在.rel.data中。

下面展示了ELF重定位条目的格式：每个条目都表示一个必须被重定位的引用，并指明如何计算被修改的引用（下面会有具体的示例）

```
typedef struct { 
    long offset;    /* 需要被修改的引用的节偏移量 */ 
    long type:32,   /* 告知链接器如何修改新的引用 */ 
	 symbol:32;      /* 标识被修改引用应该指向的符号 */ 
    long addend;    /* 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整 */
} Elf64_Rela; 
```
ELF定义了32种不同的重定位类型type，这里只叙述两种最基本的重定位类型：
- R_X86_64_PC32。**重定位一个使用32位PC相对地址的引用**。一个PC相对地址就是距程序计数器（PC）的当前运行时值得偏移量。当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值加上PC的当前运行时值，得到有效地址（如call指令的目标），PC值通常是下一条指令在内存中的地址。
- R_X86_64_32。**重定位一个使用32位绝对地址的引用**。通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。

## 链接器如何重定位符号引用
我们将最上面的运行示例反汇编得到：

```
main.o:     file format elf64-x86-64
main.o
architecture: i386:x86-64, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x0000000000000000

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000018  0000000000000000  0000000000000000  00000040  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000008  0000000000000000  0000000000000000  00000058  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  0000000000000000  0000000000000000  00000060  2**2
                  ALLOC
  3 .comment      0000002a  0000000000000000  0000000000000000  00000060  2**0
                  CONTENTS, READONLY
  4 .note.GNU-stack 00000000  0000000000000000  0000000000000000  0000008a  2**0
                  CONTENTS, READONLY
  5 .eh_frame     00000030  0000000000000000  0000000000000000  00000090  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
SYMBOL TABLE:
0000000000000000 l    df *ABS*	0000000000000000 main.c
0000000000000000 l    d  .text	0000000000000000 .text
0000000000000000 l    d  .data	0000000000000000 .data
0000000000000000 l    d  .bss	0000000000000000 .bss
0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack
0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame
0000000000000000 l    d  .comment	0000000000000000 .comment
0000000000000000 g     F .text	0000000000000018 main
0000000000000000 g     O .data	0000000000000008 array
0000000000000000         *UND*	0000000000000000 sum

Disassembly of section .text:   .text中对于main.o的反汇编

0000000000000000 <main>:
   0:	48 83 ec 08          	sub    $0x8,%rsp
   4:	be 02 00 00 00       	mov    $0x2,%esi
   9:	bf 00 00 00 00       	mov    $0x0,%edi
			a: R_X86_64_32	array
   e:	e8 00 00 00 00       	callq  13 <main+0x13>
			f: R_X86_64_PC32	sum-0x4
  13:	48 83 c4 08          	add    $0x8,%rsp
  17:	c3                   	retq  
```
**这些重定位条目告诉链接器对sum的引用要使用32位PC相对地址进行重定位，而对array的引用要使用32位绝对地址进行重定位**。

加载器对对应位置上的符号引用进行修改重定位，在后续加载的时候，加载器会把这些节中的字节直接复制到内存，不再进行任何修改地执行这些指令。