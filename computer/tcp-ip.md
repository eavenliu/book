# TCP/IP协议簇

## 分层
网络协议通常分不同层次进行开发，每一层分别负责不同的通信功能。

一个协议簇，比如TCP/IP，是一组不同层次上的多个协议的组合。 **TCP/IP通常被认为是一个四层协议系统**，如下图所示：

![tcpip-type](/Users/liujie/Desktop/gitbook/image/computer/tcpip-type.png)

- 链路层：**有时也称作数据链路层或网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网卡**。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节；
- 网络层：**有时也称作互联网层，处理分组在网络中的活动，例如分组的选路**。在TCP/IP协议簇中，网络层协议包括IP协议（网际协议）， ICMP协议（ Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。
- 运输层（传输层）：**主要为两台主机上的应用程序提供端到端的通信**。在TCP/IP协议簇中，有两个互不相同的传输协议：**TCP（传输控制协议）**和**UDP（用户数据报协议）**。
> TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。
> 另一方面， UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。任何必需的可靠性必须由应用层来提供。

- 应用层：**负责处理特定的应用程序细节**。几乎各种不同的TCP/IP实现都会提供下面这些通用的应用程序：
Telnet 远程登录、FTP 文件传输协议、SMTP 简单邮件传送协议、SNMP 简单网络管理协议

我们很容易可以看出来网络层与应用层的差别：前者处理有关通信媒介的细节（以太网、令牌环网等），而后者处理某个特定的用户应用程序（FTP、 Telnet等）。但是，**为什么要把网络层和传输层分开呢？**为了理解这一点，我们必须把视野从单个网络扩展到一组网络。

我们通过路由器将一个个小的网络连接，成为一个庞大的互联网（Internet）。路由器的好处是为不同类型的物理网络提供连接：以太网、令牌环网、点对点的链接和FDDI（光纤分布式数据接口）等等。

下面是一个包含两个网络的互连网：**一个以太网和一个令牌环网**，通过一个路由器互相连接。尽管这里是两台主机通过路由器进行通信，实际上以太网中的任何主机都可以与令牌环网中的任何主机进行通信。我们可以划分出端系统（ End system ）（两边的两台主机）和中间系统（ Intermediate system）（中间的路由器）。应用层和运输层使用端到端（End - to - end）协议。在图中，只有端系统需要这两层协议。但是，网络层提供的却是逐跳（ Hop - by - hop）协议，两个端系统和每个中间系统都要使用它。

![ftpToFtp](/Users/liujie/Desktop/gitbook/image/computer/ftpToFtp.png)

**在TCP/IP协议簇中，网络层IP提供的是一种不可靠的服务**。也就是说，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。而另一方面，TCP在不可靠的IP层上提供了一个可靠的运输层。为了提供这种可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。由此可见，**运输层和网络层分别负责不同的功能**。

**连接网络的另一个途径是使用网桥**。网桥是在链路层上对网络进行互连，而路由器则是在网络层上对网络进行互连。网桥使得多个局域网（LAN）组合在一起，这样对上层来说就好像是一个局域网。
TCP/IP倾向于使用路由器而不是网桥来连接网络，因此我们将着重介绍路由器。

## TCP/IP的分层
在TCP/IP协议簇中，有很多种协议：

![tcpipProcrol](/Users/liujie/Desktop/gitbook/image/computer/tcpipProcrol.png)

**TCP和UDP是两种最为著名的运输层协议，二者都使用IP作为网络层协议**。（即该协议下层支撑是IP协议）**虽然TCP使用不可靠的IP服务，但它却提供一种可靠的传输层服务**。

**UDP为应用程序发送和接收数据报**。
- 一个数据报是指从发送方传输到接收方的一个信息单元（例如，发送方指定的一定字节数的信息）。

但是与TCP不同的是，UDP是不可靠的，它不能保证数据报能安全无误地到达最终目的。

**IP**是网络层上的主要协议，同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。

**ICMP**是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。尽管ICMP主要被IP使用，但应用程序也有可能访问它。我们将分析两个流行的诊断工具， Ping和Traceroute（第7章和第8章），它们都使用了ICMP。

**IGMP**是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。

**ARP（地址解析协议）和RARP（逆地址解析协议）** 是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。

## Internet地址--IP地址
互联网上的每个接口必须有一个唯一的Internet地址（也称作IP地址）。IP地址长32bit。Internet地址并不采用平面形式的地址空间，如 1、 2、 3等。IP地址具有一定的结构，五类不同的互联网地址格式如下图所示：

![intenetAddressType](/Users/liujie/Desktop/gitbook/image/computer/intenetAddressType.png)

这些32位的地址通常写成四个十进制的数，其中每个整数对应一个字节。这种表示方法称作“点分十进制表示法（ Dotted decimal notation）”。

![ip](/Users/liujie/Desktop/gitbook/image/computer/ip.png)

如当前电脑的IP地址：113.110.227.236，是一个A类地址。区分各类地址的最简单方法是看它的第一个十进制整数。

需要再次指出的是，多接口主机具有多个IP地址，其中每个接口都对应一个IP地址。由于互联网上的每个接口必须有一个唯一的IP地址，因此必须要有一个管理机构为接入互
联网的网络分配IP地址---互联网络信息中心，InterNIC，InterNIC只分配网络号。主机号的分配由系统管理员来负责。

有三种IP地址：
- 单播地址（目的为单个主机）
- 广播地址（目的端为给定网络上的所有主机）
- 多播地址（目的端为同一组内的所有主机）

## 域名系统
尽管通过IP地址可以识别主机上的网络接口，进而访问主机，但是人们最喜欢使用的还是主机名。**在TCP/IP领域中，域名系统（DNS）是一个分布的数据库，由它来提供IP地址和主机名之间的映射信息。**

现在，我们必须理解，任何应用程序都可以调用一个标准的库函数来查看给定名字的主机的IP地址。类似地，系统还提供一个逆函数—给定主机的IP地址，查看它所对应的主机名。

## 封装
**当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部
信息）**，该过程如下图所示。 

数据表示：
- TCP传给IP的数据单元：称作**TCP报文段**或简称为TCP段（TCP segment）
- IP传给网络接口层的数据单元，称作**IP数据报(IP datagram)**。通过以太网传输的比特流称作**帧(Frame)**。

下图中帧头和帧尾下面所标注的数字是典型以太网帧首部的字节长度。**以太网数据帧的物理特性是其长度必须在46～1500字节之间**。在后面分析最小长度的数据帧，最大长度的数据帧。

![tcpipDataSeg](/Users/liujie/Desktop/gitbook/image/computer/tcpipDataSeg.png)

更准确地说，上图IP和网络接口层之间传送的数据单元应该是分组（packet）。分组既可以是一个IP数据报，也可以是IP数据报的一个片（fragment）。

**UDP数据与TCP数据基本一致。唯一的不同是UDP传给IP的信息单元称作UDP数据报（UDP datagram），而且UDP的首部长为8字节。**

**由于TCP、UDP、ICMP和IGMP协议都要向IP传送数据，因此IP必须在生成的IP首部中加入某种标识，以表明数据属于哪一层**。为此，IP在首部中存入一个长度为8bit的数值，称作**协议域**。 
- 1表示为ICMP协议；
- 2表示为IGMP协议；
- 6表示为TCP协议；
- 17表示为UDP协议。

类似地，许多应用程序都可以使用TCP或UDP来传送数据。传输层协议在生成报文首部时要存入一个应用程序的标识符。TCP和UDP都用一个**16bit的端口号**来表示不同的应用程序。TCP和UDP把源端口号和目的端口号分别存入报文首部中。

网络接口分别要发送和接收IP、 ARP和RARP数据，因此也必须在以太网的帧首部中加入某种形式的标识，以指明生成数据的网络层协议。为此，以太网的帧首部也有一个16bit的帧类型域。

## 分用
**当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议**。这个过程称作**分用（Demultiplexing）**。如下图：

![tcpipDataSplit](/Users/liujie/Desktop/gitbook/image/computer/tcpipDataSplit.png)

## 客户端-服务器模型
大部分网络应用程序在编写时都假设一端是客户，另一端是服务器，其目的是为了让服务器为客户提供一些特定的服务。
可以将这种服务分为两种类型：**重复型或并发型**。重复型服务器通过以下步骤进行交互：
- I1. 等待一个客户请求的到来。
- I2. 处理客户请求。
- I3. 发送响应给发送请求的客户。
- I4. 返回I1步

重复型服务器主要的问题发生在I2状态。在这个时候，它不能为其他客户机提供服务。

相应地，并发型服务器采用以下步骤：
- C1. 等待一个客户请求的到来。
- C2. 启动一个新的服务器来处理这个客户的请求。在这期间可能生成一个新的进程、任务
或线程，并依赖底层操作系统的支持。这个步骤如何进行取决于操作系统。生成的新服务器
对客户的全部请求进行处理。处理结束后，终止这个新服务器。
C3. 返回C1步

并发服务器的优点在于它是利用生成其他服务器的方法来处理客户的请求。

**一般来说，TCP服务器是并发的，而UDP服务器是重复的，但也存在一些例外。**

## 端口号
前面已经指出过，**TCP和UDP采用16 bit的端口号来识别应用程序。那么这些端口号是如何选择的呢？**

**服务器一般都是通过知名端口号来识别的**。例如，
- 对于每个TCP/IP实现来说，FTP服务器的TCP端口号都是21；
- 每个Telnet服务器的TCP端口号都是23；
- 每个TFTP (简单文件传送协议)服务器的UDP端口号都是69；
- 任何TCP/IP实现所提供的服务都用知名的 1～1023之间的端口号。这些知名端口号由Internet号分配机构（ Internet Assigned Numbers Authority, IANA）来管理。

> 到1992年为止，知名端口号介于1～255之间。 256～1023之间的端口号通常都是由Unix系统占用，以提供一些特定的Unix服务—也就是说，提供一些只有Unix系统才有的、而其他操作系统可能不提供的服务

客户端通常对它所使用的端口号并不关心，只需保证该端口号在本机上是唯一的就可以了。**客户端口号又称作临时端口号**（即存在时间很短暂）。这是因为它通常只是在用户运行该客户程序时才存在，而服务器则只要主机开着的，其服务就运行。

大多数T C P / I P实现给临时端口分配 1 0 2 4～5 0 0 0之间的端口号。大于 5 0 0 0的端口号是为其他服务器预留的（ I n t e r n e t上并不常用的服务)。我们可以在后面看见许多这样的给临时端口分配端口号的例子。

大多数Unix系统的文件/etc/services都包含了人们熟知的端口号。为了找到Telnet服务器和域名系统的端口号，可以运行以下语句：

```
root@ubuntu:/# grep telnet /etc/services 
telnet		23/tcp
rtelnet		107/tcp				# Remote Telnet
rtelnet		107/udp
telnets		992/tcp				# Telnet over SSL
tfido		60177/tcp			# fidonet EMSI over telnet
root@ubuntu:/# grep domain /etc/services 
domain		53/tcp				# Domain Name Server
domain		53/udp

```
Unix系统有**保留端口号**的概念。只有具有超级用户特权的进程才允许给它自己分配一个保留端口号。

## 应用编程使用接口
**使用TCP/IP协议的应用程序通常采用两种应用编程接口（API）：socket和TLI（运输层接口： Transport Layer Interface）**。前者有时称作“Berkeley socket”，表明它是从伯克利版发展而来的。后者起初是由 AT&T开发的，有时称作XTI（ X/Open运输层接口），以承认X/Open这个自己定义标准的国际计算机生产商所做的工作。 XTI实际上是TLI的一个超集。

## 小结
TCP/IP协议簇分为四层：链路层、网络层、运输层和应用层，每一层各有不同的责任。在TCP/IP中，网络层和运输层之间的区别是最为关键的：**网络层（IP）提供点到点的服务，而运输层（TCP和UDP）提供端到端的服务**。（数据传输的可靠性是通过数据链路层和网络层的点对点和传输层的端对端保证的。端到端与点到点是针对网络中传输的两端设备间的关系而言的。）

> End-to-End（端到端通信）：端到端通信是针对传输层来说的，它是一个网络连接，指的是在数据传输之前，在发送端与接收端之间（忽略中间有多少设备）为数据的传输建立一条链路，链路建立以后，发送端就可以发送数据，知道数据发送完毕，接收端确认接收成功。 也就是说在数据传输之前，先为数据的传输开辟一条通道，然后在进行传输。从发送端发出数据到接收端接收完毕，结束。

> Point-to-Point（点到点通信）：点到点通信是针对数据链路层或网络层来说的，点对点是基于MAC地址和或者IP地址，是指一个设备发数据给与该这边直接连接的其他设备，这台设备又在合适的时候将数据传递给与它相连的下一个设备，通过一台一台直接相连的设备把数据传递到接收端。

> Hop-by-hop（逐跳）：（与端到端请求头部类比，一般作为http的头部字段）此类头部字段只对单次转发有效。会因为转发给缓存/代理服务器而失效。 HTTP 1.1 版本之后，如果要使用Hop-by-hop头部字段则需要提供Connection字段。

一个互联网是网络的网络。构造互联网的共同基石是路由器，它们在IP层把网络连在一起。第一个字母大写的Internet是指分布在世界各地的大型互联网，其中包括 1万多个网络和超过100万台主机。

在一个互联网上，每个接口都用IP地址来标识，尽管用户习惯使用主机名而不是IP地址。域名系统为主机名和IP地址之间提供动态的映射。端口号用来标识互相通信的应用程序。服务器使用知名端口号，而客户使用临时设定的端口号。

# 链路层-TODO

# IP协议：国际协议
**IP是TCP/IP协议簇中最为核心的协议。所有的TCP、UDP、ICMP及IGMP数据都以IP数据报格式传输**。

**不可靠（unreliable）的意思是它不能保证IP数据报能成功地到达目的地**。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）。

**无连接（connectionless）这个术语的意思是IP并不维护任何关于后续数据报的状态信息**。每个数据报的处理是相互独立的。这也说明，IP数据报可以不按发送顺序接收。如果一信源向相同的信宿发送两个连续的数据报（先是A，然后是B），每个数据报都是独立地进行路由选择，可能选择不同的路线，因此 B可能在A到达之前先到达。

在本章，我们将简要介绍IP首部中的各个字段，讨论IP路由选择和子网的有关内容。介绍两个有用的命令： **ifconfig和netstat**。关于I P首部中一些字段的细节，将留在以后使用这些字段的时候再进行讨论。

## IP首部
IP数据报的格式如下图所示。普通的IP首部长为20个字节，除非含有选项字段：

![ip-header](/Users/liujie/Desktop/gitbook/image/computer/ip-header.png)

分析上图的首部。最高位在左边，记为 0 bit；最低位在右边，记为 31 bit。

**4个字节的32 bit值以下面的次序传输：首先是 0～7 bit，其次8～15 bit，然后16～23 bit，最后是24~31 bit**。**这种传输次序称作big endian字节序**。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。以其他形式存储二进制整数的机器，如little endian格式，则必须在传输数据之前把首部转换成网络字节序。

目前的**协议版本**号是4，因此IP协议有时也称作IPv4。 

**首部长度**指的是首部占32 bit字的数目，包括任何选项。由于它是一个4bit字段，因此首部最长为60个字节。普通IP数据报（没有任何选择项）字段的值是5。

**服务类型（TOS）**字段包括：

- 一个 3bit的优先权子字段（现在已被忽略）；
- 4bit的TOS子字段。**4 bit的TOS分别代表：最小时延、最大吞吐量、最高可靠性和最小费用**。4bit中只能置其中1bit。如果所有4bit均为0，那么就意味着是一般服务；
- 1bit未用位但必须置0。

**总长度字段**是指整个IP数据报的长度，以字节为单位。利用首部长度字段和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16比特，所以IP数据报最长可达65535字节。当数据报被分片时，该字段的值也随着变化。

**尽管可以传送一个长达65535字节的IP数据报，但是大多数的链路层都会对它进行分片**。而且，主机也要求不能接收超过576字节的数据报。**由于TCP把用户数据分成若干片，因此一般来说这个限制不会影响TCP。**在后面的章节中将遇到大量使用UDP的应用（RIP，TFTP，BOOTP，DNS，以及SNMP），它们都限制用户数据报长度为512字节，小于576字节。但是，事实上现在大多数的实现（特别是那些支持网络文件系统NFS的实现）允许超过8192字节的IP数据报。

总长度字段是IP首部中必要的内容，因为一些数据链路（如以太网）需要填充一些数据以达到最小长度。尽管以太网的最小帧长为46字节，但是IP数据可能会更短。如果没有总长度字段，那么IP层就不知道46字节中有多少是IP数据报的内容。

**标识字段**唯一地标识主机发送的每一份数据报。**通常每发送一份报文它的值就会加1**。在后面介绍分片和重组时再详细讨论它。同样，在讨论分片时再来分析**标志字段**和**片偏移字段**。

**TTL（time-to-live）生存时间字段**设置了数据报可以经过的最多路由器数。**它指定了数据报的生存时间**。TTL的初始值由源主机设置（通常为32或64），一旦经过一个处理它的路由器，
它的值就减去1。当该字段的值为0时，数据报就被丢弃，并发送ICMP报文通知源主机。后面我们讨论Traceroute程序时将再回来讨论该字段。

**协议字段**，根据它可以识别是哪个协议向IP传送数据。

**首部检验和字段**是根据IP首部计算的检验和码。它不对首部后面的数据进行计算。ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。

为了计算一份数据报的IP检验和：
1. 首先把检验和字段置为 0；
2. 然后，对首部中每个16bit进行二进制反码求和（整个首部看成是由一串16 bit的字组成），结果存在检验和字段中；
3. 当收到一份IP数据报后，同样对首部中每个16 bit进行二进制反码的求和。由于接收方在计算过程中包含了发送方存在首部中的检验和，因此，如果首部在传输过程中没有发生任何差错，那么接收方计算的结果应该为全1。如果结果不是全1（即检验和错误），那么IP就丢弃收到的数据报。但是不生成差错报文，由上层去发现丢失的数据报并进行重传。

ICMP、IGMP、UDP和TCP都采用相同的检验和算法，尽管TCP和UDP除了本身的首部和数据外，在IP首部中还包含不同的字段。**由于路由器经常只修改TTL字段（减1），因此当路由器转发一份报文时可以增加它的检验和，而不需要对IP整个首部进行重新计算。**

每一份IP数据报都包含**源IP地址**和**目的IP地址**，它们都是32 bit的值。

最后一个字段是**任选项**，是数据报中的一个可变长的可选信息。目前，这些任选项定义如下：
- 安全和处理限制（用于军事领域）
- 记录路径（让每个路由器都记下它的IP地址）
- 时间戳（让每个路由器都记下它的IP地址和时间）
- 宽松的源站选路（为数据报指定一系列必须经过的IP地址）
- 严格的源站选路（与宽松的源站选路类似，但是要求只能经过指定的这些地址，不能
经过其他的地址）。

这些选项很少被使用，并非所有的主机和路由器都支持这些选项。

选项字段一直都是以 32 bit作为界限，在必要的时候插入值为 0的填充字节。这样就保证IP首部始终是32 bit的整数倍（这是首部长度字段所要求的）。

## IP路由选择
从概念上说，IP路由选择是简单的，特别对于主机来说。**如果目的主机与源主机直接相连（如点对点链路）或都在一个共享网络上（以太网或令牌环网），那么IP数据报就直接送到目的主机上。否则，主机把数据报发往一默认的路由器上，由路由器来转发该数据报。大多数的主机都是采用这种简单机制**。

在后面我们将讨论更一般的情况，即**IP层既可以配置成路由器的功能，也可以配置成主机的功能** 。当今的大多数多用户系统，包括几乎所有的Unix系统，都可以配置成一个路由器。我们可以为它指定主机和路由器都可以使用的简单路由算法。**本质上的区别在于主机从不把数据报从一个接口转发另一个接口，而路由器则要转发数据报** 。内含路由器功能的主机应该从不转发数据报，除非它被设置成那样。

**在一般的体制中，IP可以从TCP、UDP、ICMP和IGMP接收数据报（即在本地生成的数据报）并进行发送，或者从一个网络接口接收数据报（待转发的数据报）并进行发送** 。**IP层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次**。

- 当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果确实是这样，数据报就被送到由IP首部协议字段所指定的协议模块进行处理。
- 如果数据报的目的不是这些地址，那么（1）如果IP层被设置为路由器的功能，那么就对数据报进行转发（也就是说，像下面对待发出的数据报一样处理）；否则（2）数据报被丢弃。

**路由表**中的每一项都包含下面这些信息：
- **目的IP地址** 。它既可以是一个完整的主机地址，也可以是一个网络地址，由该表目中的标志字段来指定（如下所述）。主机地址有一个非0的主机号，以指定某一特定的主机，而网络地址中的主机号为0，以指定网络中的所有主机（如以太网，令牌环网）。
- **下一站（或下一跳）路由器（next-hop router）的IP地址** ，或者有直接连接的网络IP地址。下一站路由器是指一个在直接相连网络上的路由器，通过它可以转发数据报。下一站路由器不是最终的目的，但是它可以把传送给它的数据报转发到最终目的。
- **标志** 。其中**一个标志指明目的IP地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口**。
- 为数据报的传输指定一个网络接口。

**IP路由选择是逐跳地（hop-by-hop）进行的。** 从这个路由表信息可以看出，IP并不知道到达任何目的的完整路径（当然，除了那些与主机直接相连的目的）。所有的IP路由选择只为数
据报传输提供下一站路由器的IP地址。它假定下一站路由器比发送数据报的主机更接近目的，而且下一站路由器与该主机是直接相连的。

**IP路由选择主要完成以下这些功能** ：
1. **搜索路由表，寻找能与目的IP地址完全匹配的表目**（网络号和主机号都要匹配）。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）；
2. **搜索路由表，寻找能与目的网络号相匹配的表目**。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。目的网络上的所有主机都可以通过这个表目来处置。例如，一个以太网上的所有主机都是通过这种表目进行寻径的。这种搜索网络的匹配方法必须考虑可能的子网掩码。关于这一点我们在下一节中进行讨论；
3. **搜索路由表，寻找标为“默认（default）”的表目**。如果找到，则把报文发送给该表目指定的下一站路由器。

如果上面这些步骤都没有成功，那么该数据报就不能被传送。如果不能传送的数据报来自本机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。

**完整主机地址匹配在网络号匹配之前执行。只有当它们都失败后才选择默认路由。默认路由，以及下一站路由器发送的ICMP间接报文（如果我们为数据报选择了错误的默认路由），是IP路由选择机制中功能强大的特性。**

**为一个网络指定一个路由器，而不必为每个主机指定一个路由器，这是IP路由选择机制的另一个基本特性** 。这样做可以极大地缩小路由表的规模，比如Internet上的路由器有只有几
千个表目，而不会是超过100万个表目。

### 举例说明
1、我们的主机bsdi有一个IP数据报要发送给主机sun。双方都在同一个以太网上。

当IP从某个上层收到这份数据报后，它搜索路由表，发现目的 P地址（140.252.13.33）在一个直接相连的网络上（以太网140.252.13.0）。于是，在表中找到匹配网络地址。

数据报被送到以太网驱动程序，然后作为一个以太网数据帧被送到sun主机上。IP数据报中的目的地址是sun的IP地址（140.252.13.33），而在链路层首部中的目的地址是48bit的sun主
机的以太网接口地址。这个48bit的以太网地址是用ARP协议获得的（后面详细说明）。

数据报的传输过程如图：

![image](https://note.youdao.com/yws/res/21480/C895F8EAE6484794AE1FFE47CF36424F)

2、主机bsdi有一份IP数据报要传到ftp.uu.net主机上，它的IP地址是192.48.96.9。经过的前三个路由器如下图所示。
- **首先，主机bsdi搜索路由表，但是没有找到与主机地址或网络地址相匹配的表目，因此只能用默认的表目**，把数据报传给下一站路由器，即主机sun；
- 当数据报从bsdi被传到sun主机上以后，目的IP地址是最终的信宿机地址（192.48.96.9），但是链路层地址却是sun主机的以太网接口地址；
- 当sun收到数据报后，它发现数据报的目的IP地址并不是本机的任一地址，而sun已被设置成具有路由器的功能，因此它把数据报进行转发。经过搜索路由表，选用了默认表目；
- 根据sun的默认表目，它把数据报转发到下一站路由器netb，该路由器的地址是140.252.1.183。数据报是经过点对点SLIP链路被传送的，采用最小封装格式。这里，我们没有给出像以太网链路层数据帧那样的首部，因为在SLIP链路中没有那样的首部；
- 当netb收到数据报后，它执行与sun主机相同的步骤：数据报的目的地址不是本机地址，而netb也被设置成具有路由器的功能，于是它也对该数据报进行转发。采用的也是默认路由表目，把数据报送到下一站路由器gateway（140.252.1.4）。位于以太网140.252.1上的主机netb用ARP获得对应于140.252.1.4的48 bit以太网地址。这个以太网地址就是链路层数据帧头上的目的地址；
- 路由器gateway也执行与前面两个路由器相同的步骤。它的默认路由表目所指定的下一站路由器IP地址是140.252.104.2。

![image](https://note.youdao.com/yws/res/21470/A82BED603E5C4DAF9FE5928AD4DF32E7)

这个例子有一些关键点：
- 该例子中的所有主机和路由器都使用了默认路由。事实上，大多数主机和一些路由器可以用默认路由来处理任何目的，除非它在本地局域网上；
- **数据报中的目的IP地址始终不发生任何变化，所有的路由选择决策都是基于这个目的IP地址**；
- **每个链路层可能具有不同的数据帧首部，而且链路层的目的地址（如果有的话）始终指的是下一站的链路层地址**。在例子中，两个以太网封装了含有下一站以太网地址的链路层首部，但是SLIP链路没有这样做。以太网地址一般通过ARP获得。

## 子网寻址
现在所有的主机都要求支持**子网编址**（RFC 950 [Mogul and Postel 1985]）。**不是把IP地址看成由单纯的一个网络号和一个主机号组成，而是把主机号再分成一个子网号和一个主机号**。

这样做的原因是因为A类和B类地址为主机号分配了太多的空间，可分别容纳的主机数为2^24-2和2^16-2。事实上，在一个网络中人们并不安排这么多的主机。由于全0或全1的主机号都是无效的，因此我们把总数减去2。

在InteNIC获得某类IP网络号后，就由当地的系统管理员来进行分配，由他（或她）来决定是否建立子网，以及分配多少比特给子网号和主机号。例如，**这里有一个B类网络地址（140.252），在剩下的16bit中，8bit用于子网号，8bit用于主机号，格式下图所示。这样就允许有254个子网，每个子网可以有254台主机**。

![image](https://note.youdao.com/yws/res/21488/9C860899558942F29D7BF4A19F7F44C5)

许多管理员采用自然的划分方法，**即把B类地址中留给主机的16bit中的前8bit作为子网地址，后8bit作为主机号**。这样用点分十进制方法表示的IP地址就可以比较容易确定子网号。但是，并不要求A类或B类地址的子网划分都要以字节为划分界限。

子网对外部路由器来说隐藏了内部网络组织（一个校园或公司内部）的细节。在我们的网络例子中，所有的IP地址都有一个B类网络号140.252。但是其中有超过30个子网，多于400台主机分布在这些子网中。由一台路由器提供了Internet的接入，如下图所示。

在这个图中，我们把大多数的路由器编号为 Rn， n是子网号。与30个C类地址相比，用一个包含30个子网的B类地址的好处是，它可以缩小Internet路由表的规模。B类地址140.252被划分为若干子网的事实对于所有子网以外的Internet路由器都是透明的。**为了到达IP地址开始部分为140.252的主机，外部路由器只需要知道通往IP地址140.252.104.1的路径。这就是说，对于网络140.252只需一个路由表目，而如果采用30个C类地址，则需要30个路由表目。因此，子网划分缩减了路由表的规模**。

子网对于子网内部的路由器是不透明的。如下图所示，一份来自Internet的数据报到达gateway，它的目的地址是140.252.57.1。路由器gateway需要知道子网号是57，然后把它送到kpno。同样，kpno必须把数据报送到R55，最后由R55把它送到R57。

![image](https://note.youdao.com/yws/res/21468/D99CB74A5AC241A0807E64E45964BCB0)

## 子网掩码
**任何主机在引导时进行的部分配置是指定主机IP地址**。大多数系统把IP地址存在一个磁盘文件里供引导时读用。（也有无盘引导）

**除了IP地址以外，主机还需要知道有多少比特用于子网号及多少比特用于主机号**。这是在引导过程中通过子网掩码来确定的。这个掩码是一个32bit的值，其中值为 1的比特留给网络号和子网号，为 0的比特留给主机号。

下图是一个B类地址的两种不同的子网掩码格式。第一个例子是noao.edu网络采用的子网划分方法，子网号和主机号都是8bit宽。第二个例子是一个B类地址划分成10bit的子网号和6bit的主机号。

![image](https://note.youdao.com/yws/res/21474/6F5E85FA6506460CA6FC66C9049B898D)

尽管IP地址一般以点分十进制方法表示，但是子网掩码却经常用十六进制来表示，特别是当界限不是一个字节时，因为子网掩码是一个比特掩码。

给定IP地址和子网掩码以后，主机就可以确定IP数据报的目的是：
1. 本子网上的主机；
2. 本网络中其他子网中的主机；
3. 其他网络上的主机。

如果知道本机的IP地址，那么就知道它是否为A类、 B类或C类地址(从I P地址的高位可以得知)，也就知道网络号和子网号之间的分界线。而根据子网掩码就可知道子网号与主机号之间的分界线。

### 举例
假设我们的主机地址是140.252.1.1（一个B类地址），而子网掩码为255.255.255.0（其中8bit为子网号，8bit为主机号）。
- 如果目的IP地址是140.252.4.5，那么我们就知道B类网络号是相同的（140.252），但是子网号是不同的（1和4）。用子网掩码在两个IP地址之间的比较如图 3 - 8所示
- 如果目的IP地址是140.252.1.22，那么B类网络号还是一样的（140.252），而且子网号也是一样的（1），但是主机号是不同的；
- 如果目的IP地址是192.43.235.6（一个C类地址），那么网络号是不同的，因而进一步的比较就不用再进行了。

![image](https://note.youdao.com/yws/res/21476/BFC63BDAD21543A49736CC786BA5C11A)

给定两个I P地址和子网掩码后，IP路由选择功能一直进行这样的比较。

## 特殊IP地址
经过子网划分的描述，现在介绍7个特殊的IP地址，如图3-9所示。在这个图中，0表示所有的比特位全为0；-1表示所有的比特位全为1；netid、subnetid和hostid分别表示不为全0或全1的对应字段。子网号栏为空表示该地址没有进行子网划分。

![image](https://note.youdao.com/yws/res/21463/ECDEEDE1C4CE48779B8D11AD2033176A)

## ifconfig命令
到目前为止，我们已经讨论了链路层和IP层，现在可以介绍TCP/IP对网络接口进行配置和查询的命令了。ifconfig(8)命令一般在引导时运行，以配置主机上的每个接口。

ifconfig命令一般支持TCP/IP以外的其他协议簇，而且有很多参数。关于这些细节可以查看系统说明书。

## netstat命令
netstat(1)命令也提供系统上的接口信息。 -i参数将打印出接口信息， -n参数则打印出IP地址，而不是主机名字

```
root@ubuntu:~# netstat -in
Kernel Interface table
Iface      MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg
ens33     1500 26006164      0      0 0       7737132      0      0      0 BMRU
lo       65536 36109276      0      0 0      36109276      0      0      0 LRU

```
这个命令打印出每个接口的MTU、输入分组数、输入错误、输出分组数、输出错误、冲突以及当前的输出队列长度。

## 小结
本章开始描述了IP首部的格式，并简要讨论了首部中的各个字段。我们还介绍了**IP路由选择**，并指出主机的路由选择可以非常简单：**如果目的主机在直接相连的网络上，那么就把数据报直接传给目的主机，否则传给默认路由器。**

在进行路由选择决策时，主机和路由器都使用**路由表**。**在表中有三种类型的路由：特定主机型、特定网络型和默认路由型**。路由表中的表目具有一定的优先级。在选择路由时，主
机路由优先于网络路由，最后在没有其他可选路由存在时才选择默认路由。

**IP路由选择是通过逐跳来实现的**。**数据报在各站的传输过程中目的IP地址始终不变，但是封装和目的链路层地址在每一站都可以改变**。大多数的主机和许多路由器对于非本地网络的数据报都使用默认的下一站路由器。

**A类和B类地址一般都要进行子网划分。用于子网号的比特数通过子网掩码来指定** 。我们为此举了一个实例来详细说明，即作者所在的子网，并介绍了变长子网的概念。**子网的划分缩小了Internrt路由表的规模，因为许多网络经常可以通过单个表目就可以访问了**。接口和网络的有关信息通过ifconfig和netstat命令可以获得，包括接口的 I P地址、子网掩码、广播地址以及MTU等。

# IP选路
选路是IP最重要的功能之一。下图是IP层处理过程的简单流程。需要进行选路的数据报可以由本地主机产生，也可以由其他主机产生。在后一种情况下，主机必须配置成一个路由器，否则通过网络接口接收到的数据报，如果目的地址不是本机就要被丢弃（例如，悄无声息地被丢弃）。

在图中，我们还描述了一个路由守护程序（daemon），通常这是一个用户进程。在Unix系统中，大多数普通的守护程序都是路由程序和网关程序（术语daemon指的是运行在后台的进程，它代表整个系统执行某些操作。daemon一般在系统引导时启动，在系统运行期间一直存在）。在某个给定主机上运行何种路由协议，如何在相邻路由器上交换选路信息，以及选路协议是如何工作的，所有这些问题都是非常复杂的，我们主要的目的是了解单个IP层如何作出路由决策。

下图所示的路由表经常被IP访问（在一个繁忙的主机上，一秒钟内可能要访问几百次），但是它被路由守护程序更新的频度却要低得多（可能大约30秒种一次）。当接收到ICMP重定向报文时，路由表也要被更新。在本章中，我们还将用netstat命令来显示路由表。

![image](https://note.youdao.com/yws/res/21464/2C3A180D5B9B4C21B59F812522DFAE63)

## 选路的原理
开始讨论IP选路之前，首先要理解内核是如何维护路由表的。路由表中包含的信息决定了IP层所做的所有决策：
1. 搜索匹配的主机地址；
2. 搜索匹配的网络地址；
3. 搜索默认表项（默认表项一般在路由表中被指定为一个网络表项，其网络号为 0）。

**匹配主机地址步骤始终发生在匹配网络地址步骤之前**。

**IP层进行的选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。这区别于选路策略，它只是一组决定把哪些路由放入路由表的规则。IP执行选路机制，而路由守护程序则一般提供选路策略。**

### 简单路由表
使用命令“netstat -rn” 列出路由表信息：

```
root@ubuntu:~# netstat -rn
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
0.0.0.0         192.168.100.1   0.0.0.0         UG        0 0          0 ens33
169.254.0.0     0.0.0.0         255.255.0.0     U         0 0          0 ens33
192.168.100.0   0.0.0.0         255.255.255.0   U         0 0          0 ens33
```
第1行说明，当目标IP找不到时，使用默认路由地址（0.0.0.0），那么网关（路由器）将把分组转发给192.168.100.1。

对于一个给定的路由器，可以打印出五种不同的标志（Flag）：
- U 该路由可以使用；
- G 该路由是到一个网关（路由器）。如果没有设置该标志，说明目的地是直接相连的；
- H 该路由是到一个主机，也就是说，目的地址是一个完整的主机地址。如果没有设置该标志，说明该路由是到一个网络，而目的地址是一个网络地址：一个网络号，或者网络号与子网号的组合；
- D 该路由是由重定向报文创建的；
- M 该路由已被重定向报文修改。

**标志G**是非常重要的，因为由**它区分了间接路由和直接路由（对于直接路由来说是不设置标志G的）**。其区别在于，发往直接路由的分组中不但具有指明目的端的IP地址，还具有其链路层地址。当分组被发往一个间接路由时，IP地址指明的是最终的目的地，但是链路层地址指明的是网关（即下一站路由器）。

**理解G和H标志之间的区别是很重要的**。 G标志区分了直接路由和间接路由，如上所述。但是H标志表明，目的地址（netstat命令输出第一行）是一个完整的主机地址。没有设置H标志说明目的地址是一个网络地址（主机号部分为 0）。当为某个目的IP地址搜索路由表时，主机地址项必须与目的地址完全匹配，而网络地址项只需要匹配目的地址的网络号和子网号就可以了。另外，大多数版本的netstat命令首先打印出所有的主机路由表项，然后才是网络路由表项。

**参考记数Refcnt（Reference count）列给出的是正在使用路由的活动进程个数**。面向连接的协议如TCP在建立连接时要固定路由。如果在主机svr4和slip之间建立Telnet连接，可以看到参考记数值变为1。建立另一个Telnet连接时，它的值将增加为2，依此类推。

其他参数暂不解释。

**主机路由表的复杂性取决于主机所在网络的拓扑结构。**
- 最简单的（也是最不令人感兴趣的）情况是主机根本没有与任何网络相连。TCP/IP协议仍然能用于这样的主机，但是只能与自己本身通信！这种情况下的路由表只包含环回接口一项；
- 接下来的情况是主机连在一个局域网上，只能访问局域网上的主机。这时路由表包含两项：**一项是环回接口，另一项是局域网**（如以太网）；
- 如果主机能够通过单个路由器访问其他网络（如Internet）时，那么就要进行下一步。一般情况下增加一个默认表项指向该路由器。
- 如果要新增其他的特定主机或网络路由，那么就要进行最后一步

### 初始化路由表
我们从来没有说过这些路由表是如何被创建的。每当初始化一个接口时（通常是用ifconfig命令设置接口地址），就为接口自动创建一个直接路由。对于点对点链路和环回接口来说，路由是到达主机（例如，设置 H标志）。对于广播接口来说，如以太网，路由是到达网络。

到达主机或网络的路由如果不是直接相连的，那么就必须加入路由表。一个常用的方法是在系统引导时显式地在初始化文件中运行route命令。

```
route add default sun 1
route add slip bsdi 1
```
第3个参数（default和slip）代表目的端，第4个参数代表网关（路由器），最后一个参数代表路由的度量(metric)。route命令在度量值大于0时要为该路由设置G标志，否则，当耗费值为0时就不设置G标志

一些系统允许在某个文件中指定默认的路由器，如 /etc/defaultrouter。于是在每次重新启动系统时都要在路由表中加入该默认项。

初始化路由表的其他方法是运行路由守护程序或者用较新的路由器发现协议。

### 没有到达目的地的路由
我们所有的例子都假定对路由表的搜索能找到匹配的表项，即使匹配的是默认项。**如果路由表中没有默认项，而又没有找到匹配项，这时会发生什么情况呢**？

结果取决于该IP数据报是由主机产生的还是被转发的（例如，我们就充当一个路由器）。如果数据报是由本地主机产生的，那么就给发送该数据报的应用程序返回一个差错，或者是“主机不可达差错”或者是“网络不可达差错”。如果是被转发的数据报，那么就给原始发送端发送一份ICMP主机不可达的差错报文。

## ICMP协议--TODO

## 小结
IP路由操作对于运行TCP/IP的系统来说是最基本的，不管是主机还是路由器。路由表项的内容很简单，包括：5bit标志、目的IP地址（主机、网络或默认）、下一站路由器的IP地址
（间接路由）或者本地接口的IP地址（直接路由）及指向本地接口的指针。主机表项比网络表项具有更高的优先级，而网络表项比默认项具有更高的优先级。

**系统产生的或转发的每份IP数据报都要搜索路由表，它可以被路由守护程序或ICMP重定向报文修改**。系统在默认情况下不转发数据报，除非进行特殊的配置。用route命令可以进入静态路由，可以利用新ICMP路由器发现报文来初始化默认表项，并进行动态修改。主机在启动时只有一个简单的路由表，它可以被来自默认路由器的ICMP重定向报文动态修改。

# 动态选路协议-TODO

# UDP：用户数据报协议-TODO
# DNS：域名系统-TODO



# TCP：传输控制协议
TCP提供了一种可靠的面向连接的字节流传输层服务。主要学习：
- 什么是TCP
- 如何建立和终止一个TCP连接
- 了解正常的数据传输过程，包括交互使用（远程登录）和批量数据传送（文件传输）
- TCP超时及重传的技术细节
- 介绍两种TCP其他的定时器
- 概述TCP新的特性以及TCP的性能

## TCP的服务
**尽管TCP和UDP都使用相同的网络层协议（IP），TCP却向应用层提供与UDP完全不同的服务。TCP提供一种面向连接的、可靠的字节流服务。**

**面向连接**意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。

在一个TCP连接中，仅有两方进行彼此通信，**TCP通过下列方式来提供可靠性**：
- **应用数据被分割成TCP认为最适合发送的数据块** 。这和UDP完全不同，应用程序产生的数据报长度将保持不变。**由TCP传递给IP的信息单位称为报文段或段（segment）；**
- 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段;
- 当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒;
- **TCP将保持它首部和数据的检验和** 。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。
- 既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。
- 既然IP数据报会发生重复，TCP的接收端必须丢弃重复的数据。
- **TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间** 。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。

**两个应用程序通过TCP连接交换8bit字节构成的字节流** 。TCP不在字节流中插入记录标识符。我们将这称为**字节流服务**（byte stream service）。如果一方的应用程序先传10字节，又传20字节，再传50字节，连接的另一方将无法了解发方每次发送了多少字节。收方可以分4次接收这80个字节，每次接收20字节。一端将字节流放到TCP连接上，同样的字节流将出现在TCP连接的另一端。

**另外，TCP对字节流的内容不作任何解释**。TCP不知道传输的数据字节流是二进制数据，还是ASCII字符、EBCDIC字符或者其他类型数据。对字节流的解释由TCP连接双方的应用层解释。

## TCP的首部
TCP数据被封装在一个IP数据报中，如下图：

![image](https://note.youdao.com/yws/res/21484/5CA038676E464F16B3652CE50B9572CE)

下图显示TCP首部的数据格式。如果不计任选字段，它通常是20个字节：

![image](https://note.youdao.com/yws/res/21475/F22EDD63943D4A71B4AF338A982C7AAF)

**我们现在来分析其结构组成：**

- **每个TCP段都包含源端和目的端的端口号，用于寻找发端和收端应用进程**。这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接。

> 有时，一个IP地址和一个端口号也称为一个插口（socket）。插口对（socket pair） (包含客户IP地址、客户端口号、服务器IP地址和服务器端口号的四元组 )可唯一确定互联网络中每个TCP连接的双方。

- **序号用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节**。如果将字节流看作在两个应用程序间的单向流动，则TCP用序号对每个字节进行计数。序号是32bit的无符号数，序号到达 2^32－1后又从0开始。

> 当建立一个新的连接时，SYN标志变1。序号字段包含由这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加1，因为SYN标志消耗了一个序号（将在下章详细介绍如何建立和终止连接，届时我们将看到FIN标志也要占用一个序号）。

- 既然每个传输的字节都被计数，**确认序号包含发送确认的一端所期望收到的下一个序号**。因此，确认序号应当是上次已成功收到数据字节序号加1。只有ACK标志（下面介绍）为1时确认序号字段才有效。发送ACK无需任何代价，因为32 bit的确认序号字段和ACK标志一样，总是TCP首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置，ACK标志也总是被设置为1。

**TCP为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输**。因此，连接的每一端必须保持每个方向上的传输数据序号。

**TCP可以表述为一个没有选择确认或否认的滑动窗口协议（滑动窗口协议用于数据传输将在后面介绍）**。我们说TCP缺少选择确认是因为TCP首部中的确认序号表示发方已成功收
到字节，但还不包含确认序号所指的字节。当前还无法对数据流中选定的部分进行确认。例如，如果1～1024字节已经成功收到，下一报文段中包含序号从2049～3072的字节，收端并不能确认这个新的报文段。它所能做的就是发回一个确认序号为1025的ACK。它也无法对一个报文段进行否认。例如，如果收到包含1025～2048字节的报文段，但它的检验和错，TCP接收端所能做的就是发回一个确认序号为1025的ACK。在后面我们将看到重复的确认如何帮助确定分组已经丢失。

- **首部长度给出首部中32bit字的数目。需要这个值是因为任选字段的长度是可变的**。这个字段占4bit，因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节。

- **在TCP首部中有6个标志比特。它们中的多个可同时被设置为1**。我们在这儿简单介绍它们的用法：

| 标志 | 说明                                                         |
| ---- | ------------------------------------------------------------ |
| URG  | 紧急指针（urgent pointer）有效                               |
| ACK  | 确认序号有效                                                 |
| PSH  | 接收方应该尽快将这个报文段交给应用层                         |
| RST  | 重建连接                                                     |
| SYN  | 同步序号用来发起一个连接。这个标志和下一个标志将在下面介绍。 |
| FIN  | 发端完成发送任务                                             |

**TCP的流量控制由连接的每一端通过声明的窗口大小来提供**。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个16bit字段，因而窗口大小最大为65535字节。

检验和覆盖了整个的TCP报文段：TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。 

**只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号**。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。

**最常见的可选字段是最长报文大小，又称为MSS (Maximum Segment Size)。** 每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。

## 小结
**TCP提供了一种可靠的面向连接的字节流传输层服务**。我们简单地介绍了TCP首部中的各个字段，并在随后的几章里详细讨论它们。

**TCP将用户数据打包构成报文段；它发送数据后启动一个定时器；另一端对收到的数据进行确认，对失序的数据重新排序，丢弃重复数据；TCP提供端到端的流量控制，并计算和验证一个强制性的端到端检验和。**

许多流行的应用程序如Telnet、Rlogin、FTP和SMTP都使用TCP。

# TCP连接的建立和终止
TCP是一个面向连接的协议。

## 连接的建立与终止
为了了解一个TCP连接在建立及终止时发生了什么，我们在系统svr4上键入下列命令：

![image](https://note.youdao.com/yws/res/21487/95BA90C855F2498DBD0761C60374D494)

telnet命令在与丢弃 (discard)服务对应的端口上与主机bsdi建立一条TCP连接。这服务类型正是我们需要观察的一条连接建立与终止的服务类型，而不需要服务器发起任何数据交换。

### tcpdump的输出
下图显示了这条命令产生TCP报文段的tcpdump输出：

![image](https://note.youdao.com/yws/res/21462/1906EB1099FB4FCFAA94B8F841284671)

这7个TCP报文段仅包含TCP首部。没有任何数据。对于TCP段，每个输出行开始按如下格式显示：

源 > 目的: 标志

这里的标志代表TCP首部中6个标志比特中的4个。

![image](https://note.youdao.com/yws/res/21477/1365A0B2E81A4DA0B5CDCC8325DE3897)

在第1行中，字段1415531521:1415531521(0)表示分组的序号是1415531521，而报文段中数据字节数为0**。tcpdump显示这个字段的格式是开始的序号、一个冒号、隐含的结尾序号及圆括号内的数据字节数**。显示序号和隐含结尾序号的优点是便于了解数据字节数大于0时的隐含结尾序号。这个字段只有在满足条件（1）报文段中至少包含一个数据字节；或者（2）SYN、FIN或RST被设置为1时才显示。图18-1中的第1、2、4和6行是因为标志比特被置为1而显示这个字段的，在这个例子中通信双方没有交换任何数据。

在第2行中，字段ack 1415531522表示确认序号。它只有在首部中的ACK标志比特被设置1时才显示。

每行显示的字段 win 4096表示发端通告的窗口大小。在这些例子中，我们没有交换任何数据，窗口大小就维持默认情况下的4096。

最后一个字段 <mss 1024>表示由发端指明的最大报文段长度选项。发端将不接收超过这个长度的TCP报文段。这通常是为了避免分段。

### 建立连接协议
上面的例子是为了建立一条TCP连接：
1. 请求端（通常称为客户）**发送一个SYN段指明客户打算连接的服务器的端口**，以及初始序号（ISN，在这个例子中为1415531521）。这个SYN段为报文段1。
2. 服务器发回包含服务器的初始序号的SYN报文段（报文段2）作为应答。同时，将确认序号设置为客户的ISN加1以对客户的SYN报文段进行确认。一个SYN将占用一个序号。
3. 客户必须将确认序号设置为服务器的ISN加1以对服务器的SYN报文段进行确认（报文段3）。

这三个报文段完成连接的建立。这个过程也称为三次握手（three-way handshake）。

![image](https://note.youdao.com/yws/res/21471/A67CF9D0BE774726BBA52C8CD0C3A442)

发送第一个SYN的一端将执行主动打开（active open）。接收这个SYN并发回下一个SYN的另一端执行被动打开（ passive open）。

当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。**ISN随时间而变化，因此每个连接都将具有不同的ISN**。 RFC 793 [Postel 1981c]指出ISN可看作是一个32比特的计
数器，每4ms加1。**这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它作错误的解释**。

### 连接终止协议
**建立一个连接需要三次握手，而终止一个连接要经过4次挥手。这由TCP的半关闭（half-close）造成的。** 既然一个TCP连接是全双工（即数据在两个方向上能同时传递），因此每个方向必须单独地进行关闭。**这原则就是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向连接。当一端收到一个FIN，它必须通知应用层另一端几经终止了那个方向的数据传送。发送FIN通常是应用层进行关闭的结果。**

首先进行关闭的一方（即发送第一个FIN）将执行主动关闭，而另一方（收到这个FIN）执行被动关闭。通常一方完成主动关闭而另一方完成被动关闭。

当服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。同时TCP服务器还向应用程序（即丢弃服务器）传送一个文件结束符。接着这个服务器程序就关闭它的连接，导致它的TCP端发送一个FIN（报文段6），客户必须发回一个确认，并将确认序号设置为收到序号加1（报文段7）。

下图显示了终止一个连接的典型挥手顺序。我们省略了序号。在这个图中，发送FIN将导致应用程序关闭它们的连接，这些FIN的ACK是由TCP软件自动产生的。

![image](https://note.youdao.com/yws/res/21481/6084572E79F1426E9B490D83ACABCD49)

### 正常的tcpdump输出
对所有的数值很大的序号进行排序是很麻烦的，因此默认情况下tcpdump只在显示SYN报文段时显示完整的序号，而对其后的序号则显示它们与初始序号的相对偏移值。

![image](https://note.youdao.com/yws/res/21473/330510B8E9F5403C8C51C01328231DB2)

## 最大报文段长度-MSS
**最大报文段长度（MSS）表示TCP传往另一端的最大块数据的长度**。当一个连接建立时，连接的双方都要通告各自的MSS。我们已经见过MSS都是1024。这导致IP数据报通常是40字节长：20字节的TCP首部和20字节的IP首部首部。

当建立一个连接时，每一方都有用于通告它期望接收的MSS选项（MSS选项只能出现在SYN报文段中）。如果一方不接收来自另一方的MSS值，则MSS就定为默认值536字节（这个默认值允许20字节的IP首部和20字节的TCP首部以适合576字节IP数据报)。

**一般说来，如果没有分段发生， MSS还是越大越好。报文段越大允许每个报文段传送的数据就越多，相对IP和TCP首部有更高的网络利用率。** 当TCP发送一个SYN时，或者是因为一个本地应用进程想发起一个连接，或者是因为另一端的主机收到了一个连接请求，它能将MSS值设置为外出接口上的MTU长度减去固定的IP首部和TCP首部长度。对于一个以太网，MSS值可达1460字节。使用IEEE802.3的封装（参见2.2节），它的MSS可达1452字节。

> 当双方都在一个本地以太网上时都规定MSS为1460。 [Mogul 1993] 的比较显示了在以太网上1460的MSS在性能上比1024的MSS更好

> 如果目的IP地址为“非本地的(nonlocal)”，MSS通常的默认值为536。而区分地址是本地还是非本地是简单的，如果目的IP地址的网络号与子网号都和我们的相同，则是本地的；如果目的IP地址的网络号与我们的完全不同，则是非本地的；如果目的IP地址的网络号与我们的相同而子网号与我们的不同，则可能是本地的，也可能是非本地的。

MSS让主机限制另一端发送数据报的长度。加上主机也能控制它发送数据报的长度，这将使以较小MTU连接到一个网络上的主机避免分段。

考虑我们的主机slip，通过MTU为296的SLIP链路连接到路由器bsdi上。下图显示这些系统和主机sun。

![image](https://note.youdao.com/yws/res/21486/88AA52385A5543B38D2070BE78B3E15E)

从sun向slip发起一个TCP连接，并使用tcpdump来观察报文段。图中显示这个连接的建立（省略了通告窗口大小）

![image](https://note.youdao.com/yws/res/21482/7953985ACFD440B09C0CF49882C7D6D7)

在这个例子中，sun发送的报文段不能超过256字节的数据，因为它收到的MSS选项值为256（第2行）。此外，由于slip知道它外出接口的MTU长度为296，即使sun已经通告它的MSS为1460，但为避免将数据分段，它不会发送超过256字节数据的报文段。系统允许发送的数据长度小于另一端的MSS值。

## TCP的半关闭
TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的半关闭。正如我们早些时候提到的只有很少的应用程序使用它。

为了使用这个特性，编程接口必须为应用程序提供一种方式来说明“我已经完成了数据传送，因此发送一个文件结束（FIN）给另一端，但我还想接收另一端发来的数据，直到它给我发来文件结束（FIN）”。

如果应用程序不调用close而调用shutdown，且第2个参数值为1，则插口的API支持半关闭。然而，大多数的应用程序通过调用close终止两个方向的连接。

## TCP的状态变迁

![image](https://note.youdao.com/yws/res/21461/F1E705AC7C564273BF042A350A93D978)

在这个图中要注意的：
- 第一点是一个状态变迁的子集是“典型的”。我们用粗的实线箭头表示正常的客户端状态变迁，用粗的虚线箭头表示正常的服务器状态变迁。
- 第二点是两个导致进入ESTABLISHED状态的变迁对应打开一个连接，而两个导致从ESTABLISHED状态离开的变迁对应关闭一个连接。ESTABLISHED状态是连接双方能够进行双向数据传递的状态。
- 将图中左下角 4个状态放在一个虚线框内，并标为“主动关闭”。其他两个状态（CLOSE_WAIT和LAST_ACK）也用虚线框住，并标为“被动关闭”。
- 在这个图中11个状态的名称（CLOSED,LISTEN,SYN_SENT等）是有意与netstat命令显示的状态名称一致。netstat对状态的命名几乎与在RFC793中的最初描述一致。CLOSED状态不是一个真正的状态，而是这个状态图的假想起点和终点。
- 只有当SYN_RCVD状态是从LISTEN状态（正常情况）进入，而不是从SYN_SENT状态（同时打开）进入时，从SYN_RCVD回到LISTEN的状态变迁才是有效的。这意味着如果我们执行被动关闭（进入LISTEN），收到一个SYN，发送一个带ACK的SYN（进入SYN_RCVD），然后收到一个RST，而不是一个ACK，便又回到LISTEN状态并等待另一个连接请求的到来。

下图显示了在正常的TCP连接的建立与终止过程中，客户与服务器所经历的不同状态。

![image](https://note.youdao.com/yws/res/21472/47DAB8E146F84B01B488BF426C0DE91A)

假定在图中左边的客户执行主动打开，而右边的服务器执行被动打开。尽管图中显示出由客户端执行主动关闭，但和早前我们提到的一样，另一端也能执行主动关闭。
可以使用图18-12的状态图来跟踪图18-13的状态变化过程，以便明白每个状态的变化。

### 2MSL等待状态
**TIME_WAIT状态也称为2MSL等待状态**。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime）。**它是任何报文段被丢弃前在网络内的最长时间。我们知道这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。**

> RFC 793 [Postel 1981c] 指出MSL为2分钟。然而，实现中的常用值是30秒， 1分钟，或2分钟。

**在实际应用中，对IP数据报TTL的限制是基于跳数，而不是定时器**。对一个具体实现所给定的MSL值，处理的原则是：**当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。**

遗憾的是，大多数TCP实现（如伯克利版）强加了更为严格的限制。在2MSL等待期间，插口中使用的本地端口在默认情况下不能再被使用。

**在连接处于2MSL等待时，任何迟到的报文段将被丢弃。** 因为处于2MSL等待的、由该插口对(socketpair)定义的连接在这段时间内不能被再用，因此当要建立一个有效的连接时，来自该连接的一个较早替身（incarnation）的迟到报文段作为新连接的一部分不可能不被曲解（一个连接由一个插口对来定义。一个连接的新的实例（instance）称为该连接的替身）。

上面的示例图中客户执行主动关闭并最终进入TIME_WAIT是正常的。而服务器通常执行被动关闭，不会进入TIME_WAIT状态。这暗示如果我们终止一个客户程序，并立即重新启动这个客户程序，则这个新客户程序将不能重用相同的本地端口（因为进入了2MSL等待时间，连接处于半关闭状态），会报类似错：Address already in Use。

### 平静时间概念
对于来自某个连接的之前的迟到报文段，2MSL等待可防止将它解释成使用相同插口对（IP:port,IP:port）的新连接的一部分。但这只有在处于2MSL等待连接中的主机处于正常工作状态时才有效。

如果使用处于2MSL等待端口的主机出现故障，它会在MSL秒内重新启动，并立即使用故障前仍处于2MSL的插口对来建立一个新的连接吗？如果是这样，在故障前从这个连接发出而迟到的报文段会被错误地当作属于重启后新连接的报文段。无论如何选择重启后新连接的初始序号，都会发生这种情况。

为了防止这种情况， RFC 793指出T C P在重启动后的MSL秒内不能建立任何连接。这就称为**平静时间(quiet time)**。

### FIN_WAIT_2状态
**在进入连接状态FIN_WAIT_2时，我们已经向连接另一端发出了FIN，并且另一端也回复ack对它进行确认。** 

除非我们在实行半关闭，否则将等待另一端的应用层意识到它已收到一个文件结束符说明，并向我们发一个FIN来关闭另一方向的连接。**只有当另一端的进程完成这个关闭，我们这端才会从FIN_WAIT_2状态进入TIME_WAIT状态。** （另一端应用发回ack关闭确认后，另一端确认关闭后继续发送一个FIN到本端）

**这意味着我们这端可能永远保持这个状态。另一端也将处于CLOSE_WAIT状态，并一直保持这个状态直到应用层决定进行关闭。** 这样会导致连接无法被关闭，连接数被占满，以致于无法继续提供服务。

许多伯克利实现采用如下方式来防止这种在FIN_WAIT_2状态的无限等待。
- 如果执行主动关闭的应用层将进行全关闭，而不是半关闭来说明它还想接收数据。设置一个定时器，如果这个连接空闲10分钟75秒，TCP将进入CLOSED状态。在实现代码的注释中确认这个实现代码违背协议的规范。

## 复位报文段
我们已经介绍了**TCP首部中的RST比特是用于“复位”的****。一般说来，无论何时一个报文段发往基准的连接（referencedconnection）出现错误，TCP都会发出一个复位报文段**（**这里提到的“基准的连接”是指由目的IP地址和目的端口号以及源IP地址和源端口号指明的连接**）。

### 到不存在的端口的连接请求
**产生复位的一种常见情况是当连接请求到达时，目的端口没有进程正在听。** 
- 对于UDP，当一个数据报到达目的端口时，该端口没在使用，它将产生一个ICMP端口不可达的信息。
- 而TCP则使用复位。

产生这个例子也很容易，我们可使用 Te l n e t客户程序来指明一个目的端口没在使用的情况：

![image](https://note.youdao.com/yws/res/21560/801C59CA361D4461B79F72F525E288A2)

### 异常终止一个连接
一般终止连接有两种方式：
- 终止一个连接的正常方式是一方发送FIN。有时这也称为**有序释放（orderlyrelease）**，因为在所有排队数据都已发送之后才发送FIN，正常情况下没有任何数据丢失。
- 也可能发送一个复位报文段而不是FIN来中途释放一个连接。有时称这为**异常释放（abortiverelease）**。

异常终止一个连接对应用程序来说**有两个优点**：
1. 丢弃任何待发数据并立即发送复位报文段；
2. RST的接收方会区分另一端执行的是异常关闭还是正常关闭。**应用程序使用的API必须提供产生异常关闭而不是正常关闭的手段。**

举例说明：使用sock程序能够观察这种异常关闭的过程

SocketAPI通过“lingeronclose”选项（SO_LINGER）提供了这种异常关闭的能力。我们加上-L选项并将停留时间设为0。这将导致连接关闭时进行复位而不是正常的FIN。我们连接到处于服务器上的sock程序，并键入一输入行：
```
bsdi % sock -L0 svr4 8888 这是客户程序，服务器程序显示后面
hello, world 键入一行输入，它被发往到另一端
^ D 键入文件结束符，终止客户程序
```
tcpdump为：

![image](https://note.youdao.com/yws/res/21581/9BCC14EFFFDA4B7CACC25EB644A6C58B)

使用sock程序能够观察这种异常关闭的过程。第6行对应为终止客户程序而键入的文件结束符（Control_D）。由于我们指明使用异常关闭而不是正常关闭（命令行中的-L0选项），因此主机bsdi端的TCP发送一个RST而不是通常的FIN。RST报文段中包含一个序号和确认序号。需要注意的是**RST报文段不会导致另一端产生任何响应，另一端根本不进行确认。收到RST的一方将终止该连接，并通知应用层连接复位**。我们在服务器上得到下面的差错信息：

```
svr4 % sock -s 8888 作为服务器进程运行，在端口 8 8 8 8监听
hello, world 这行是客户端发送的
read error: Connection reset by peer
```
### 检测半打开连接
**如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的TCP连接称为半打开（Half-Open）的** 。任何一端的主机异常都可能导致发生这种情况。**只要不打算在半打开连接上传输数据，仍处于连接状态的一方就不会检测另一方已经出现异常。**

半打开连接的另一个常见原因是当客户主机突然掉电而不是正常的结束客户应用程序后再关机。

举个例子：

![image](https://note.youdao.com/yws/res/21595/5238CB87F11F441B82C639A627565E53)

tcpdump输出显示：

![image](https://note.youdao.com/yws/res/21599/448F04F60C1342B5ABAE07AD530BFB44)

第1~3行是正常的连接建立过程。第4行向丢弃服务器发送字符行“hi there”，第5行是确认。

然后是断开svr4的以太网电缆，重新启动svr4，并重新接上电缆。这个过程几乎需要190秒。接着从客户端输入下一行（即“anotherline”），当我们键入回车键后，这一行被发往服务器（图18-16的第6行）。这导致服务器产生一个响应，但要注意的是由于服务器主机经过重新启动，它的ARP高速缓存为空，因此需要一个ARP请求和应答（第7、8行）。第9行表示RST被发送出去。客户收到复位报文段显示连接已被另一端的主机终止（Telnet客户程序发出的最后信息不再有什么价值）。

## 同时打开
两个应用程序同时彼此执行主动打开的情况是可能的，尽管发生的可能性极小。每一方必须发送一个SYN，且这些SYN必须传递给对方。这需要每一方使用一个对方熟知的端口作为本地端口。这又称为**同时打开（simultaneousopen）**。

例如，主机A中的一个应用程序使用本地端口7777，并与主机B的端口8888执行主动打开。主机B中的应用程序则使用本地端口8888，并与主机A的端口7777执行主动打开。

**TCP是特意设计为了可以处理同时打开，对于同时打开它仅建立一条连接而不是两条连接**（其他的协议簇，最突出的是OSI运输层，在这种情况下将建立两条连接而不是一条连接）。当出现同时打开的情况时，状态变迁与图18-13所示的不同。两端几乎在同时发送SYN，并进入SYN_SENT状态。当每一端收到SYN时，状态变为SYN_RCVD（如图18-12），同时它们都再发SYN并对收到的SYN进行确认。当双方都收到SYN及相应的ACK时，状态都变迁为ESTABLISHED。图18-17显示了这些状态变迁过程。

![image](https://note.youdao.com/yws/res/21621/6385530E42C549F6B078871F2DE3CEF5)

**一个同时打开的连接需要交换 4个报文段，比正常的三次握手多一个。此外，要注意的是我们没有将任何一端称为客户或服务器，因为每一端既是客户又是服务器。**

## 同时关闭
我们在以前讨论过一方（通常但不总是客户方）发送第一个FIN执行主动关闭。双方都执行主动关闭也是可能的，TCP协议也允许这样的同时关闭（simultaneousclose）。

当应用层发出关闭命令时，两端均从ESTABLISHED变为FIN_WAIT_1。这将导致双方各发送一个FIN，两个FIN经过网络传送后分别到达另一端。收到FIN后，状态由FIN_WAIT_1变迁到CLOSING，并发送最后的ACK。当收到最后的ACK时，状态变化为TIME_WAIT。

![image](https://note.youdao.com/yws/res/21631/32CA9273D07741B19D89A1B54D7ECEFD)

同时关闭与正常关闭使用的段交换数目相同。

## TCP选项
//TODO

## TCP服务设计

### 呼入连接请求队列
一个并发服务器调用一个新的进程来处理每个客户请求，因此处于被动连接请求的服务器应该始终准备处理下一个呼入的连接请求。那正是使用并发服务器的根本原因。但仍有可能出现当服务器在创建一个新的进程时，或操作系统正忙于处理优先级更高的进程时，到达多个连接请求。当服务器正处于忙时，TCP是如何处理这些呼入的连接请求？

在伯克利的TCP实现中采用以下规则：
1. 正等待连接请求的一端有一个固定长度的连接队列，该队列中的连接已被TCP接受（即三次握手已经完成），但还没有被应用层所接受。注意区分TCP接受一个连接是将其放入这个队列，而应用层接受连接是将其从该队列中移出。
2. 应用层将指明该队列的最大长度，这个值通常称为**积压值 (backlog)**。它的取值范围是0~5之间的整数，包括0和5（大多数的应用程序都将这个值说明为 5）。
3. 当一个连接请求（即SYN）到达时，TCP使用一个算法，根据当前连接队列中的连接数来确定是否接收这个连接。我们期望应用层说明的积压值为这一端点所能允许接受连接的最大数目，但情况不是那么简单。**注意，积压值说明的是TCP监听的端点已被TCP接受而等待应用层接受的最大连接数。这个积压值对系统所允许的最大连接数，或者并发服务器所能并发处理的客户数，并无影响。**
4. 如果对于新的连接请求，该TCP监听的端点的连接队列中还有空间，TCP模块将对SYN进行确认并完成连接的建立。但应用层只有在三次握手中的第三个报文段收到后才会知道这个新连接时。另外，当客户进程的主动打开成功但服务器的应用层还不知道这个新的连接时，它可能会认为服务器进程已经准备好接收数据了（如果发生这种情况，服务器的TCP仅将接收的数据放入缓冲队列)。
5. 如果对于新的连接请求，连接队列中已没有空间，TCP将不理会收到的SYN。也不发回任何报文段（即不发回RST）。如果应用层不能及时接受已被TCP接受的连接，这些连接可能占满整个连接队列，客户的主动打开最终将超时。

# TCP的交互数据流

## 引言
一些有关TCP通信量的研究如[Caceresetal.1991]发现，如果按照分组数量计算，约有一半的TCP报文段包含**成块数据**（如FTP、电子邮件和Usenet新闻），另一半则包含**交互数据**（如Telnet和Rlogin）。如果按字节计算，则成块数据与交互数据的比例约为90%和10%。这是因为成块数据的报文段基本上都是满长度（full-sized）的（通常为512字节的用户数据），而交互数据则小得多（上述研究表明Telnet和Rlogin分组中通常约90%左右的用户数据小于10个字节）。

很明显，**TCP需要同时处理这两类数据，但使用的处理算法则有所不同**。本章将以Rlogin应用为例来观察交互数据的传输过程。将揭示经受时延的确认是如何工作的以及Nagle算法怎样减少了通过广域网络传输的小分组的数目，这些算法也同样适用于Telnet应用。下一章我们将介绍成块数据的传输问题。

## 交互式输入
首先来观察在一个Rlogin连接上键入一个交互命令时所产生的数据流。许多TCP/IP的初学者很吃惊地发现通常每一个交互按键都会产生一个数据分组，也就是说，每次从客户传到服务器的是一个字节的按键（而不是每次一行）。而且，Rlogin需要远程系统（服务器）回显我们（客户）键入的字符。这样就会产生4个报文段：
1. 来自客户的交互按键；
2. 来自服务器的按键确认；
3. 来自服务器的按键回显；
4. 来自客户的按键回显确认。

![image](https://note.youdao.com/yws/res/21698/6AD3B018ADE44F3D8317610E3CFF493B)

然而，我们一般可以将报文段2和3进行合并— 按键确认与按键回显一起发送。


## 经受时延的确认
**通常TCP在接收到数据时并不立即发送ACK；相反，它推迟发送，以便将ACK与需要沿该方向发送的数据一起发送（有时称这种现象为数据捎带ACK）。绝大多数实现采用的时延为200ms，也就是说，TCP将以最大200ms的时延等待是否有数据一起发送。**

## Nagle算法
在一个Rlogin连接上客户一般每次发送一个字节到服务器，这就产生了一些41字节长的分组：20字节的IP首部、20字节的TCP首部和1个字节的数据。在局域网上，这些**小分组**（被称为微小分组（tinygram））通常不会引起麻烦，因为局域网一般不会出现拥塞。但在广域网上，这些小分组则会增加拥塞出现的可能。一种简单和好的方法就是采用RFC896[Nagle1984]中所建议的**Nagle算法**。

**Nagle算法要求** ：一个TCP连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的分组，并在确认到来时以一个分组的方式发出去。该算法的优越之处在于它是自适应的：**确认到达得越快，数据也就发送得越快**。而在希望减少微小分组数目的低速广域网上，则会发送更少的分组（到“小”的含义是小于报文段的大小）。

### 关闭Nagle算法
有时我们也需要关闭Nagle算法。一个典型的例子是 X窗口系统服务器（见 3 0 . 5节）：小消息（鼠标移动）必须无时延地发送，以便为进行某种操作的交互用户提供实时的反馈
## 小结
交互数据总是以小于最大报文段长度的分组发送。在Rlogin中通常只有一个字节从客户发送到服务器。Telnet允许一次发送一行输入数据，但是目前大多数实现仍然发送一个字节。

对于这些小的报文段，接收方使用经受时延的确认方法来判断确认是否可被推迟发送，以便与回送数据一起发送。这样通常会减少报文段的数目，尤其是对于需要回显用户输入字符的Rlogin会话。

在较慢的广域网环境中，通常使用Nagle算法来减少这些小报文段的数目。这个算法限制发送者任何时候只能有一个发送的小报文段未被确认。但我们给出的一个例子也表明有时需要禁止Nagle算法的功能。

# TCP成块的数据流
## 引言
数据发送方在发送下一个数据块之前需要
等待接收对已发送数据的确认。本章我们将介绍TCP所使用的被称为滑动窗口协议的另一种形式的流量控制方法。该协议允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。

我们还将介绍TCP的PUSH标志，该标志在前面的许多例子中都出现过。此外，我们还要介绍慢启动，TCP使用该技术在一个连接上建立数据流，最后介绍成块数据流的吞吐量。

## 正常数据流

## 滑动窗口
下图用可视化的方法显示了我们在前一节观察到的滑动窗口协议。

![image](https://note.youdao.com/yws/res/21720/DD1C1F529EE14774905AF1CFB868D8CD)

在这个图中，我们将字节从 1至11进行标号。接收方通告的窗口称为提出的窗口（offered window），它覆盖了从第4字节到第9字节的区域，表明接收方已经确认了包括第 3字节在内的数据，且通告窗口大小为 6。**我们知道窗口大小是与确认序号相对应的。发送方计算它的可用窗口，该窗口表明多少数据可以立即被发送。**

**当接收方确认数据后，这个滑动窗口不时地向右移动。窗口两个边沿的相对运动增加或减少了窗口的大小**。我们使用三个术语来描述窗口左右边沿的运动：
1. 称窗口左边沿向右边沿靠近为窗口合拢。这种现象发生在数据被发送和确认时。
2. 当窗口右边沿向右移动时将允许发送更多的数据，我们称之为窗口张开。这种现象发生在另一端的接收进程读取已经确认的数据并释放了TCP的接收缓存时。
3. 当右边沿向左移动时，我们称之为窗口收缩。 Host Requirements RFC强烈建议不要使用这种方式。但TCP必须能够在某一端产生这种情况时进行处理。

![image](https://note.youdao.com/yws/res/21806/CE79EAE0A9464BF2BED47A7DB8FB8199)

**如果左边沿到达右边沿，则称其为一个零窗口，此时发送方不能够发送任何数据。**

下图展示了客户方向服务端发送8个1024字节的报文段，数据传输过程中滑动窗口协议的动态性：

![image](https://note.youdao.com/yws/res/21811/88C952047F8D4ECBAAC89CD34B42126A)

以该图为例可以总结如下几点：
1. 发送方不必发送一个全窗口大小的数据。
2. 来自接收方的一个报文段确认数据并把窗口向右边滑动。**这是因为窗口的大小是相对于确认序号的**。
3. 正如从报文段 7到报文段 8中变化的那样，窗口的大小可以减小，但是窗口的右边沿却不能够向左移动。
4. 接收方在发送一个ACK前不必等待窗口被填满。在前面我们看到许多实现每收到两个报文段就会发送一个ACK。

## 窗口大小
**由接收方提供的窗口的大小通常可以由接收进程控制，这将影响TCP的性能。**

> 4.2BSD默认设置发送和接受缓冲区的大小为2048个字节。在4.3BSD中双方被增加为4096个字节。正如我们在本书中迄今为止所看到的例子一样，SunOS4.1.3、BSD/386和SVR4仍然使用4096字节的默认大小。其他的系统，如Solaris2.2、4.4BSD和AIX3.2则使用更大的默认缓存大小，如8192或16384等

**Socket API允许进程设置发送和接收缓存的大小**。接收缓存的大小是该连接上所能够通告的最大窗口大小，有一些应用程序通过修改插口缓存大小来增加性能。

## PUSH标志
**发送方使用PUSH标志通知接收方将所收到的数据全部提交给接收进程。这里的数据包括与PUSH一起传送的数据以及接收方TCP已经为接收进程收到的其他数据。**

在最初的TCP规范中，一般假定编程接口允许发送进程告诉它的TCP何时设置PUSH标志。例如，在一个交互程序中，当客户发送一个命令给服务器时，它设置PUSH标志并停下来等待服务器的响应。通过允
许客户应用程序通知其TCP设置PUSH标志，客户进程通知TCP在向服务器发送一个报文段时不要因等待额外数据而使已提交数据在缓存中滞留。类似地，当服务器的TCP接收到一个设置了PUSH标志的报文段时，它需要立即将这些数据递交给服务器进程而不能等待判断是否还会有额外的数据到达。

然而，目前大多数的API没有向应用程序提供通知其TCP设置PUSH标志的方法，一个好的TCP实现能够自行决定何时设置这个标志。

**如果待发送数据将清空发送缓存， 则大多数的源于伯克利的实现能够自动设置PUSH标志。这意味着我们能够观察到每个应用程序写的数据均被设置了PUSH标志，因为数据在写的时候就立即被发送。**

## 慢启动
迄今为止，在本章所有的例子中，发送方一开始便向网络发送多个报文段，直至达到接收方通告的窗口大小为止。**当发送方和接收方处于同一个局域网时，这种方式是可以的。但是如果在发送方和接收方之间存在多个路由器和速率较慢的链路时，就有可能出现一些问题。一些中间路由器必须缓存分组，并有可能耗尽存储器的空间**。

现在，**TCP需要支持一种被称为“慢启动 (slow start)”的算法。该算法通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作**。

慢启动为发送方的TCP增加了另一个窗口：**拥塞窗口** (congestion window)，记为cwnd。
- 当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。
- 每收到一个ACK，拥塞窗口就增加一个报文段（cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加）。
- 发送方取拥塞窗口与通告窗口中的最小值作为发送上限。
- **拥塞窗口是发送方使用的流量控制，而通告窗口则是接收方使用的流量控制**。

发送方开始时发送一个报文段，然后等待ACK。当收到该ACK时，拥塞窗口从1增加为2，即可以发送两个报文段。当收到这两个报文段的ACK时，拥塞窗口就增加为4。这是一种指数增加的关系。

**在某些点上可能达到了互联网的容量，于是中间路由器开始丢弃分组。这就通知发送方它的拥塞窗口开得过大。**当我们在下一章讨论TCP的超时和重传机制时，将会看到它们是怎样对拥塞窗口起作用的。

举例说明：

图20-8表示的是将从主机sun发送到主机vangogh.cs.berkeley.edu的数据。这些数据将通过一个慢的SLIP链路，该链路是TCP连接上的瓶颈（我们已经在时间系列上去掉了连接建立的过程）：

![image](https://note.youdao.com/yws/res/21876/F3B13AB163E2452B8D4CB93E2ADAA2FB)

我们观察到发送方发送一个长度为512字节的报文段，然后等待ACK。该ACK在716ms后收到。这个时间是一个往返时间的指示。于是拥塞窗口增加了2个报文段，且又发送了两个报文段。当收到报文段5的ACK后，拥塞窗口增加为3。此时尽管可发送多达3个报文段，可是在下一个ACK收到之前，只发送了2个报文段。

后面将采用另一种被称为**“拥塞避免”**的技术来作为通常的实现。

## 成块的数据吞吐量
**让我们看一看窗口大小、窗口流量控制以及慢启动对传输成块数据的TCP连接的吞吐量的相互作用。**

### 带宽时延乘积
窗口应该设置为多大，在我们的例子中，作为最大的吞吐量，发送方在任何时候有8个已发送的报文段未被确认。接收方的通告窗口必须不小于这个数目，因为通告窗口限制了发送方能够发送的段的数目。

可以计算通道的容量为：capacity(bit)=bandwidth(b/s)×round-triptime(s)，一般称之为**带宽时延乘积**。这个值依赖于网络速度和两端的RTT，可以有很大的变动。例如，一条穿越美国（RTT约为60ms）的T1的电话线路（1544000b/s）的带宽时延乘积为11580字节。


### 拥塞
**当数据到达一个大的管道（如一个快速局域网）并向一个较小的管道（如一个较慢的广域网）发送时便会发生拥塞。当多个输入流到达一个路由器，而路由器的输出流小于这些输入流的总和时也会发生拥塞。**

下图显示了一个典型的大管道向小管道发送报文的情况。之所以说它典型，是因为大多数的主机都连接在局域网上，并通过一个路由器与速率相对较低的广域网相连（我们再次假定图中上半部分的报文段（9 ~ 20）都是相同的，而图中下半部分的ACK也都是相同的）。

![image](https://note.youdao.com/yws/res/22158/3BCD93E6BE9947859CEF7B7E659818D7)

在该图中，我们已经标记路由器 R 1为“瓶颈”，因为它是拥塞发生的地方。它从左侧速率较高的局域网接收数据并向右侧速率较低的广域网发送（通常R1与R3是同样的路由器，如同R2与R4一样。但这并不是必需的，有时也会使用不对称的路径）。当路由器R2将所接收到的分组发送到右侧的局域网时，这些分组之间维持与其左侧广域网上同样的间隔，尽管局域网具有更高的带宽。类似地，返回的确认之间的间隔也与其在路径中最慢的链路上的间隔一致。

在图20-13中已经假定发送方不使用慢启动，它按照局域网的带宽尽可能快地发送编号为1~20的报文段（假定接收方的通告窗口至少为20个报文段）。正如我们看到的那样，ACK之间的间隔与在最慢链路上的一致。**假定瓶颈路由器具有足够的容纳这20个分组的缓存。如果这个不能保证，就会引起路由器丢弃分组**。在后面讨论避免拥塞时会看到怎样避免这种情况。

## 紧急方式
**TCP提供了“紧急方式(urgentmode)”，它使一端可以告诉另一端有些具有某种方式的“紧急数据”已经放置在普通的数据流中。另一端被通知这个紧急数据已被放置在普通数据流中，由接收方决定如何处理。**

可以通过设置TCP首部中的两个字段来发出这种从一端到另一端的紧急数据已经被放置在数据流中的通知。**URG比特被置1，并且一个16bit的紧急指针被置为一个正的偏移量，该偏移量必须与TCP首部中的序号字段相加，以便得出紧急数据的最后一个字节的序号。**

TCP必须通知接收进程，何时已接收到一个紧急数据指针以及何时某个紧急数据指针还不在此连接上，或者紧急指针是否在数据流中向前移动。接着接收进程可以读取数据流，并必须能够被告知何时碰到了紧急数据指针。**只要从接收方当前读取位置到紧急数据指针之间有数据存在，就认为应用程序处于“紧急方式”**。在紧急指针通过之后，应用程序便转回到正常方式。

TCP本身对紧急数据知之甚少。没有办法指明紧急数据从数据流的何处开始。**TCP通过连接传送的唯一信息就是紧急方式已经开始（TCP首部中的URG比特）和指向紧急数据最后一个字节的指针。其他的事情留给应用程序去处理。**

不幸的是，许多实现不正确地称TCP的紧急方式为带外数据(out-of-banddata)。如果一个应用程序确实需要一个独立的带外信道，第二个TCP连接是达到这个目的的最简单的方法（许多运输层确实提供许多人认为的那种真正的带外数据：使用同一个连接的独立的逻辑数据通道作为正常的数据通道。这是TCP所没有提供的）。

**紧急方式有什么作用呢？** 两个最常见的例子是Telnet和Rlogin。当交互用户键入中断键时，使用紧急方式来完成这个中断。另一个例子是FTP，当交互用户放弃一个文件的传输时

## 小结
正如我们在本章一开始时讲的那样，**没有一种单一的方法可以使用TCP进行成块数据的交换。这是一个依赖于许多因素的动态处理过程，有些因素我们可以控制（如发送和接收缓存的大小），而另一些我们则没有办法控制（如网络拥塞、与实现有关的特性等）**。在本章，我们已经考察了许多TCP的传输过程，介绍了所有我们能够看到的特点和算法。

**进行成块数据有效传输的最重要的方法是TCP的滑动窗口协议**。我们考察了TCP为使发送方和接收方之间的管道充满来获得最可能快的传输速度而采用的方法。我们用带宽时延乘积衡量管道的容量，并分析了该乘积与窗口大小之间的关系。后面介绍TCP性能的时候将再次涉及这个概念。

**我们还介绍了TCP的PUSH标志，因为在跟踪结果中总是观察到它，但我们无法对它的设置与否进行控制**。本章最后一个主题是**TCP的紧急数据，人们常常错误地称其为“带外数据”。TCP的紧急方式只是一个从发送方到接收方的通知，该通知告诉接收方紧急数据已被发送，并提供该数据最后一个字节的序号。应用程序使用的有关紧急数据部分的编程接口常常都不是最佳的，从而导致更多的混乱。**

# TCP的超时与重传
## 引言
**TCP提供可靠的运输层。它使用的方法之一就是确认从另一端收到的数据。但数据和确认都有可能会丢失。 ** 

**TCP通过在发送时设置一个定时器来解决这种问题。如果当定时器溢出时还没有收到确认，它就重传该数据** 。对任何实现而言，关键之处就在于**超时和重传的策略，即怎样决定超时间隔和如何确定重传的频率。**

对每个连接的可靠保持， TCP管理4个不同的定时器：
1. 重传定时器使用于当希望收到另一端的确认。在本章我们将详细讨论这个定时器以及一些相关的问题，如拥塞避免。
2. 坚持(persist)定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。后面（TCP坚持定时器）将单独讨论这个问题。
3. 保活(keepalive)定时器可检测到一个空闲连接的另一端何时崩溃或重启。后面（TCP保活定时器）将描述这个定时器。
4. 2MSL定时器测量一个连接处于TIME_WAIT状态的时间。

## 超时与重传的简单例子
首先观察TCP所使用的重传机制，我们将建立一个连接，发送一些分组来证明一切正常，然后拔掉电缆，发送更多的数据，再观察TCP的行为。

![image](https://note.youdao.com/yws/res/22224/F495B86DDF63408789C797AAE14D1D9A)

tcpdump的输出结果（已经去掉了bsdi设置的服务类型信息）：

![image](https://note.youdao.com/yws/res/22228/19E66550A668485E9C7BFF5F45B2B4BA)

连接过程:
1. 第1、2和3行表示正常的TCP连接建立的过程;
2. 第4行是“hello, world”（12个字符加上回车和换行）的传输过程，第5行是其确认。
3. 接着我们从svr4拔掉了以太网电缆;
4. 第6行表示“and hi”将被发送。第7 ~ 18行是这个报文段的12次重传过程;
5. 而第19行则是发送方的TCP最终放弃并发送一个复位信号的过程。

现在检查连续重传之间不同的时间差，它们取整后分别为1、3、6、12、24、48和多个64秒。在本章的后面，我们将看到当第一次发送后所设置的超时时间实际上为1.5秒此后该时间在每次重传时增加1倍并直至64秒。

这个倍乘关系被称为**“指数退避 (exponential backoff )”**。

首次分组传输（第6行，24.480秒）与复位信号传输（第19行，566.488秒）之间的时间差约为9分钟，该时间在目前的TCP实现中是不可变的。

> 对于大多数实现而言，这个总时间是不可调整的。Solaris2.2允许管理者改变这个时间（E.4节中的tcp_ip_abort_interval变量），且其默认值为2分钟，而不是最常用的9分钟

## 往返时间测量
**TCP超时与重传中最重要的部分** 就是对一个给定连接的往返时间（RTT）的测量。**由于路由器和网络流量均会变化，因此我们认为这个时间可能经常会发生变化，TCP应该跟踪这些变化并相应地改变其超时时间。**

首先TCP必须测量在发送一个带有特别序号的字节和接收到包含该字节的确认之间的RTT。

## 拥塞避免算法
**慢启动算法是在一个连接上发起数据流的方法，但有时我们会达到中间路由器的极限，此时分组将被丢弃。拥塞避免算法是一种处理丢失分组的方法。**

**该算法假定由于分组受到损坏引起的丢失是非常少的（远小于1%），因此分组丢失就意味着在源主机和目的主机之间的某处网络上发生了拥塞**。有两种分组丢失(也可以称之为拥塞发生标志)的标志：
- 发生超时(如果使用超时作为拥塞指示，则需要使用一个好的RTT算法)
- 接收到重复的确认

**拥塞避免算法和慢启动算法是两个目的不同、独立的算法。但是当拥塞发生时，我们希望降低分组进入网络的传输速率，于是可以调用慢启动来作到这一点。在实际中这两个算法通常在一起实现**。

**拥塞避免算法和慢启动算法需要对每个连接维持两个变量**：**一个拥塞窗口cwnd** 和 **一个慢启动门限ssthresh** 。这样得到的算法的工作过程如下:
1. 对一个给定的连接，初始化cwnd为1个报文段，ssthresh为65535个字节;
2. **TCP输出例程的输出不能超过cwnd和接收方通告窗口的大小**。拥塞避免是发送方使用的流量控制，而通告窗口则是接收方进行的流量控制。前者是发送方感受到的网络拥塞的估计，而后者则与接收方在该连接上的可用缓存大小有关;
3. 当拥塞发生时（超时或收到重复确认），ssthresh被设置为当前窗口大小的一半（cwnd和接收方通告窗口大小的最小值，但最少为2个报文段）。此外，如果是超时引起了拥塞，则cwnd被设置为1个报文段（这就是慢启动）。
4. 当新的数据被对方确认时，就增加cwnd，但增加的方法依赖于我们是否正在进行慢启动或拥塞避免。如果cwnd小于或等于ssthresh，则正在进行慢启动，否则正在进行拥塞避免。慢启动一直持续到我们回到当拥塞发生时所处位置的半时候才停止（因为我们记录了在步骤2中给我们制造麻烦的窗口大小的一半），然后转为执行拥塞避免。

慢启动算法初始设置cwnd为1个报文段，此后每收到一个确认就加1。这会使窗口按指数方式增长：发送 1个报文段，然后是2个，接着是4个……。

**拥塞避免算法要求每次收到一个确认时将cwnd增加1/cwnd**。与慢启动的指数增加比起来，这是一种加性增长(additive increase)。我们希望在一个往返时间内最多为cwnd增加1个报文段（不管在这个RTT中收到了多少个ACK），然而慢启动将根据这个往返时间中所收到的确认的个数增加cwnd。

下面是慢启动和拥塞避免的一个可视化描述。我们以段为单位来显示cwnd和ssthresh，但它们实际上都是以字节为单位进行维护的

![image](https://note.youdao.com/yws/res/22279/1F727C00621A4929AC3F788BB38014E5)

在该图中，假定当cwnd为32个报文段时就会发生拥塞。于是设置ssthresh为16个报文段，而cwnd为1个报文段。在时刻0发送了一个报文段，并假定在时刻1接收到它的ACK，此时cwnd增加为2。接着发送了2个报文段，并假定在时刻2接收到它们的ACK，于是cwnd增加为4（对每个ACK增加1次）。这种指数增加算法一直进行到在时刻3和4之间收到8个ACK后cwnd等于ssthresh时才停止，从该时刻起，cwnd以线性方式增加，在每个往返时间内最多增加1个报文段。

正如我们在这个图中看到的那样，术语“慢启动”并不完全正确。它只是采用了比引起拥塞更慢些的分组传输速率，但在慢启动期间进入网络的分组数增加的速率仍然是在增加的。只有**在达到ssthresh拥塞避免算法起作用时，这种增加的速率才会慢下来。**

## 快速重传与快速恢复算法
我们认识到在收到一个失序的报文段时，TCP立即需要产生一个ACK（一个重复的ACK）。这个重复的ACK不应该被迟延。该重复的ACK的目的在于让对方知道收到一个失序的报文段，并告诉对方自己希望收到的序号。

由于我们不知道一个重复的ACK是由一个丢失的报文段引起的，还是由于仅仅出现了几个报文段的重新排序，因此我们等待少量重复的ACK到来。假如这只是一些报文段的重新排序，则在重新排序的报文段被处理并产生一个新的ACK之前，只可能产生1~2个重复的ACK。如果一连串收到3个或3个以上的重复ACK，就非常可能是一个报文段丢失了。于是我们就重传丢失的数据报文段，而无需等待超时定时器溢出。这就是**快速重传算法**。接下来执行的不是慢启动算法而是拥塞避免算法。这就是**快速恢复算法**。

## ICMP的差错
让我们来看一下TCP是怎样处理一个给定的连接返回的ICMP的差错。TCP能够遇到的最常见的ICMP差错就是源站抑制、主机不可达和网络不可达。

当前基于伯克利的实现对这些错误的处理是：
- 一个接收到的源站抑制引起拥塞窗口cwnd被置为1个报文段大小来发起慢启动，但是慢启动门限ssthresh没有变化，所以窗口将打开直至它或者开放了所有的通路（受窗口大小和往返时间的限制）或者发生了拥塞。
- 一个接收到的主机不可达或网络不可达实际上都被忽略，因为这两个差错都被认为是短暂现象。这有可能是由于中间路由器被关闭而导致选路协议要花费数分钟才能稳定到另一个替换路由。在这个过程中就可能发生这两个ICMP差错中的一个，但是连接并不必被关闭。相反，TCP试图发送引起该差错的数据，尽管最终有可能会超时（回想图21-1中TCP在9分钟内没有放弃的情况）。当前基于伯克利的实现记录发生的ICMP差错，如果连接超时，ICMP差错被转换为一个更合适的的差错码而不是“连接超时”。


## 重新分组
当TCP超时并重传时，它不一定要重传同样的报文段。相反，TCP允许进行重新分组而发送一个较大的报文段，这将有助于提高性能（当然，这个较大的报文段不能够超过接收方声明的MSS）。在协议中这是允许的，因为TCP是使用字节序号而不是报文段序号来进行识别它所要发送的数据和进行确认。

## 小结
本章提供了对TCP超时和重传机制的详细研究。使用的第 1个例子是一个丢失的建立连接的SYN，并观察了在随后的重传和超时中怎样使用指数退避方式。

TCP计算往返时间并使用这些测量结果来维护一个被平滑的RTT估计器和被平滑的均值偏差估计器。这两个估计器用来计算下一个重传时间。许多实现对每个窗口仅测量一次RTT。Karn算法在分组丢失时可以不测量RTT就能解决重传的二义性问题。

TCP的许多实际算法：慢启动、拥塞避免、快速重传和快速恢复。我们也能够使用拥塞窗口和慢启动门限来手工计算TCPRTT估计器，并将这些值与跟踪输出的实际数据进行比较。

以多种ICMP差错对TCP连接的影响以及TCP怎样允许对数据进行重新分组来结束本章。我们观察到“软”的ICMP差错没有引起TCP连接终止，但这些差错被保存以便在连接非正常中止时能够报告这些软差错。

# TCP的坚持定时器
我们已经看到TCP通过让接收方指明希望从发送方接收的数据字节数（即窗口大小）来进行流量控制。如果窗口大小为 0会发生什么情况呢？这将有效地阻止发送方传送数据，直到窗口变为非0为止。

ACK的传输并不可靠，也就是说，TCP不对ACK报文段进行确认，TCP只确认那些包含有数据的ACK报文段。

**如果一个确认丢失了，则双方就有可能因为等待对方而使连接终止**：**接收方等待接收数据（因为它已经向发送方通告了一个非0的窗口），而发送方在等待允许它继续发送数据的窗口更新**。

为防止这种死锁情况的发生：**发送方使用一个坚持定时器(persist timer)来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为窗口探查(window probe)。**

# TCP的保活定时器
许多TCP/IP的初学者会很惊奇地发现可以没有任何数据流通过一个空闲的TCP连接。也就是说，如果TCP连接的双方都没有向对方发送数据，则在两个TCP模块之间不交换任何信息。

例如，没有可以在其他网络协议中发现的轮询。这意味着我们可以启动一个客户与服务器建立一个连接，然后离去数小时、数天、数个星期或者数月，而连接依然保持。中间路由器可以崩溃和重启，电话线可以被挂断再连通，但是只要两端的主机没有被重启，则连接依然保持建立。

这意味着两个应用进程—**客户进程或服务器进程—都没有使用应用级的定时器来检测非活动状态，而这种非活动状态可以导致应用进程中的任何一个终止其活动**。（曾提到过的BGP每隔30秒就向对端发送一个应用的探查，就是独立于TCP的保活定时器之外的应用定时器。）

然而，许多时候一个服务器希望知道客户主机是否崩溃并关机或者崩溃又重新启动。许多实现提供的保活定时器可以提供这种能力。

保活并不是TCP规范中的一部分。Host Requirements RFC提供了3个不使用保活定时器的理由：
1. 在出现短暂差错的情况下，这可能会使一个非常好的连接释放掉；
2. 它们耗费不必要的带宽；
3. 在按分组计费的情况下会在互联网上花掉更多的钱。

保活定时器是一个有争论的功能。许多人认为如果需要，这个功能不应该在TCP中提供，而应该由应用程序来完成。

在连接两个端系统的网络出现临时故障的时候，保活选项会引起一个实际上很好的连接终止。例如，如果在一个中间路由器崩溃并重新启动时发送保活探查，那么TCP会认为客户的主机已经崩溃，而实际上所发生的并非如此。

保活功能主要是为服务器应用程序提供的。服务器应用程序希望知道客户主机是否崩溃，从而可以代表客户使用资源。

一个说明现在需要使用保活功能的常见例子是当个人计算机用户使用TCP/IP向一个使用Telnet的主机注册时。如果在一天结束时，他们仅仅关闭了电源而没有注销，那么便会留下一个半开放的连接。在图18-16中，我们看到通过一个半开放连接发送数据会导致返回一个复位，但那是在来自正在发送数据的客户端。如果客户已经消失了，使得在服务器上留下一个半开放连接，而服务器又在等待来自客户的数据，则服务器将永远等待下去。保活功能就是试图在服务器端检测到这种半开放的连接。
## 描述
在这个描述中，我们称使用保活选项的一端为服务器，而另一端则为客户。并没有什么使客户不能使用这个选项，但通常都是服务器设置这个功能。如果双方都特别需要了解对方是否已经消失，则双方都可以使用这个选项。

如果一个给定的连接在两个小时之内没有任何动作，则服务器就向客户发送一个探查报文段（我们将在随后的例子中看到这个探查报文段看起来像什么）。客户主机必须处于以下 4个状态之一。
1. 客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常工作的。服务器在两小时以后将保活定时器复位。如果在两个小时定时器到时间之前有应用程序的通信量通过此连接，则定时器在交换数据后的未来2小时再复位。
2. 客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务器将不能够收到对探查的响应，并在75秒后超时。服务器总共发送10个这样的探查，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。
3. 客户主机崩溃并已经重新启动。这时服务器将收到一个对其保活探查的响应，但是这个响应是一个复位，使得服务器终止这个连接。
4. 客户主机正常运行，但是从服务器不可达。这与状态2相同，因为TCP不能够区分状态4与状态2之间的区别，它所能发现的就是没有收到探查的响应。

服务器不用关注客户主机被关闭和重新启动的情况（这指的是一个操作员的关闭，而不是主机崩溃）。**当系统被操作员关闭时，所有的应用进程也被终止（也就是客户进程），这会使客户的TCP在连接上发出一个FIN。接收到FIN将使服务器的TCP向服务器进程报告文件结束，使服务器可以检测到这个情况。**

在第1种情况下，服务器的应用程序没有感觉到保活探查的发生。TCP层负责一切。这个过程对应用程序都是透明的，直至第2、3或4种情况发生。在这三种情况下，服务器应用程序将收到来自它的TCP的差错报告（通常服务器已经向网络发出了读操作请求，然后等待来自客户的数据。如果保活功能返回一个差错，则该差错将作为读操作的返回值返回给服务器）。在第2种情况下，差错是诸如“连接超时”之类的信息，而在第3种情况则为“连接被对方复位”。第4种情况看起来像是连接超时，也可根据是否收到与连接有关的ICMP差错来返回其他的差错。

# Sun远程过程调用
大多数的网络程序设计都是编写一些调用系统提供的函数来完成特定的网络操作的应用程序。例如，一个函数完成TCP的主动打开，另一个完成TCP的被动打开，一个函数在一个TCP连接上发送数据，另一个设置特定的协议选项（如激活TCP的keepalive定时器）。

我们提到过两个常用的用于网络编程的函数集（API）：插口(socket )和TLI。正像客户端和服务器端运行的操作系统可能会不相同一样，双方使用的API也可能会不相同。由通信协议和应用协议决定一对客户和服务器是否可以彼此通信。

一般来说，客户发送命令给服务器，服务器向客户发送应答。目前为止，我们讨论过的所有应用程序—Ping，Traceroute，选路守护程序、以及DNS、TFTP、BOOTP、SNMP、Telnet、FTP和SMTP的客户和服务器—都是采用这种方式实现的。

**远程过程调用RPC (Remote Procedure Call)是一种不同的网络程序设计方法**。客户程序编写时只是调用了服务器程序提供的函数。这只是程序员所感觉到的，实际上发生了下面一些动作。
1. 当客户程序调用远程的过程时，它实际上只是调用了一个位于本机上的、由RPC程序包生成的函数。这个函数被称为客户残桩（stub）。客户残桩将过程的参数封装成一个网络报文，并且将这个报文发送给服务器程序。
2. 服务器主机上的一个服务器残桩负责接收这个网络报文。它从网络报文中提取参数，然后调用应用程序员编写的服务器过程。
3. 当服务器函数返回时，它返回到服务器残桩。服务器残桩提取返回值，把返回值封装成一个网络报文，然后将报文发送给客户残桩。
4. 客户残桩从接收到的网络报文中取出返回值，将其返回给客户程序。

网络程序设计是通过残桩和使用诸如插口或TLI的某个API的RPC库例程来实现的，但是用户程序—客户程序和被客户程序调用的服务器过程—不会和这个API打交道。客户应用程序只是调用服务器的过程，所有网络程序设计的细节都被RPC程序包、客户残桩和服务器残桩所隐藏。一个RPC程序包提供了很多好处。
1. 程序设计更加容易，因为很少或几乎没有涉及网络编程。应用程序设计员只需要编写一个客户程序和客户程序调用的服务器过程。
2. 如果使用了一个不可靠的协议，如UDP，像超时和重传等细节就由RPC程序包来处理。这就简化了用户应用程序。
3. RPC库为参数和返回值的传输提供任何需要的数据转换。例如，如果参数是由整数和浮点数组成的，RPC程序包处理整数和浮点数在客户机和服务器主机上存储的不同形式。这个功能简化了在异构环境中的客户和服务器的编码问题。

两个常用的RPC程序包是SunRPC和开放软件基金（OSF）分布式计算环境（DCE）的RPC程序包。我们对于RPC的兴趣在于想了解SunRPC中过程调用和过程返回报文的形式，因为本章中讨论的网络文件系统使用了它们。

## Sun RPC
SunRPC有两个版本。一个版本建立在Socket API基础上，和TCP和UDP打交道。另一个称为TI-RPC的（独立于运输层），建立在TLIAPI基础上，可以和内核提供的任何运输层协议打交道。尽管本章中我们
只讨论TCP和UDP，从讨论的观点来看，两者是一样的。

下面是使用UDP时，一个RPC过程调用报文的格式，IP首部和UDP首部是标准的首部，UDP首部以下是RPC程序包定义的部分。

![image](https://note.youdao.com/yws/res/22397/DDAB4371C17148528A10183F3C984E7E)

- 事务标识符（XID）：由客户程序设置，由服务器程序返回。当客户收到一个应答，它将服务器返回的XID与它发送的请求的XID相比较。如果不匹配，客户就放弃这个报文，等待从服务器返回的下一个报文。每次客户发出一个新的RPC，它就会改变报文的XID。但是如果客户重传一个以前发送过的RPC（因为它没有收到服务器的一个应答），重传报文的XID不会修改。
- 调用(call)：变量在过程调用报文中设置为 0，在应答报文中设置为 1。
- RPC版本：当前的RPC版本是2。
- 程序号、版本号和过程号：标识了服务器上被调用的特定过程。
- 证书 (credential)：标识了客户。有些情况下，证书字段设置为空值；另外一些情况下，证书字段设置为数字形式的客户的用户号和组号。服务器可以查看证书字段以决定是否执行请求的过程。
- 验证 (verifier)：用于使用了DES加密的安全RPC。尽管证书字段和验证字段是可变长度的字段，它们的长度也作为字段的一部分被编码。
- 过程参数 (procedure parameter)：参数的格式依赖于远程过程的定义。

接收者（服务器残桩）如何知道参数字段的大小呢？
- 如果使用的是UDP协议，UDP数据报的大小减去验证字段以上所有字段的长度就是参数的大小。
- 如果使用的不是UDP而是TCP，因为**TCP是一个字节流协议，没有记录边界，所以没有固定的长度**。为了解决这个问题，**在TCP首部和XID之间增加了一个4字节的长度字段，告诉接收者这个RPC调用由多少字节组成。这也使得一个RPC调用报文在必要时可以用多个TCP段来传输。**

下面显示了一个RPC应答报文的格式。当远程过程返回时，服务器残桩将这个报文发送给客户残桩：

![image](https://note.youdao.com/yws/res/22414/F6114BAF42764493B22910E0EC473F62)

应答报文中的XID字段是从调用报文的XID字段复制而来。应答字段设置为1，以区别于调用报文。如果调用报文被接受，状态字段设置为0（如果RPC的版本号不为2，或者服务器不能鉴别客户的身份，调用报文可能被拒绝）。安全的RPC使用验证字段来标识服务器。

如果远程过程调用成功，接受状态字段置为0。一个非零的值可能表示一个不合法的版本号或者一个不合法的过程号。如果使用的不是UDP而是TCP，如同RPC调用报文一样，在TCP首部和XID字段之间插入一个4字节的长度字段。