# 系统级IO

输入/输出(I/O)是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。

输入操作是从I/O设备复制数据到主存，而输出操作是从主存复制数据到I/O设备。

# Unix I/O
一个Linux文件就是一个m个字节的序列：B0，B1，...，Bk，...，Bm-1

**所有的I/O设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对文件的读和写来执行**。这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，就做**Unix I/O**。这使得所有的输入和输出都能以一种统一且一致的方式来执行：

1. **打开文件**。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个I/O设备。内核返回一个小的非负整数，叫做**描述符**，它在后续对此文件的所有操作中标识这个文件。**内核记录有关这个打开文件的所有信息，应用程序只需记住这个描述符。**
2. Unix进程生命周期开始时都有三个打开的文件描述符给了：**标准输入（描述符为0），标准输出（描述符为1）和标准错误（描述符2）。**
3. **改变当前的文件位置**。对于每个打开的文件，内核保持着一个文件位置k，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能通过执行seek操作，显式的设置文件的当前位置为k。
4. **读写文件**。一个读操作就是从文件复制n>0个字节到内存，从当前文件位置k开始，然后将k增加到k+n。
5. **关闭文件**。当应用完成了对文件的访问之后，他就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。

# 文件
每一个Linux文件都有一个类型（type）来表明它在系统中的角色：
- **普通文件**包含任意数据。应用程序常常要区分文本文件和二进制文件，文本文件是只含有ASCII或Unicode字符的普通文件；二进制文件是其他所有文件。对内核而言，文本文件和二进制文件没有区别。
- **目录**是包含一组链接（link）的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录。每个目录至少含有两个条目：“.”是到该目录自身的链接，以及“..”是到目录层次结构中父目录的链接。
- **套接字**是用来与另一个进程进行跨网络通信的文件。

其他文件类型包含**命名通道（name pipe）**、**符号链接（symbolic link）**，以及**字符和块设备**。

Linux内核将所有文件都组织成一个**目录层次结构**，由名为“/”的根目录确定。

![linuxFileStruct](/Users/liujie/Desktop/gitbook/image/computer/linuxFileStruct.png)

目录层次结构中的位置用路径名来指定。
- 绝对路径名：以一个斜杠开始，表示从根节点开始的路径。
- 相对路径名：以文件名开始，表示从当前工作目录开始的路径。

# 打开和关闭文件
进程通过调用open函数来打开一个已存在的文件或者创建一个新文件：

```
int open(char *filename, int flags, mode_t mode);
返回：成功返回文件描述符，出错返回-1
```
open函数间filename转换为一个文件描述符，并且返回描述符数字。

flags参数指明了进程打算如何访问这个文件：
- O_RDONLY：只读
- O_WRONLY：只写
- O_RDWR：读写

flags也可以包含一个或更多的位掩码的或，如为写提供额外的指示：
- O_CREAT:如果文件不存在，就创建它的一个截断的（空）文件；
- O_TRUNC：如果文件存在，就截断它；
- O_APPEND：在每次写操作前，设置文件位置到文件的结尾处。

如：fd = open("foo.txt", O_WRONLY | O_APPEND, 0);

mode参数指定了新文件的访问权限位。

最后，进程调用close函数关闭一个打开的文件：

```
int close(int fd);
返回：成功返回0
```
# 用RIO包健壮地读写
Linux使用低级函数read和write来对打开的文件进行读写：

```
ssize_t read(int fd, void *buf, size_t n);
返回：若成功返回读的字节数，若遇到EOF（文件结束）为0，出错为-1
ssize_t write(int fd, const void *buf, size_t n);
返回：若成功则为写的字节数，出错为-1
```
在某些情况下，read和write传送的字节比应用程序要求的要少，这些不足值不代表有错误，出现这种情况原因有：
- 读时遇到EOF。
- 从终端读文本行。
- 读和写网路套接字。

为了处理上线的所述的不足值，特别是网络程序这样容易出现不足值的应用中，系统提供了RIO包来保证方便、健壮和高效的I/O。RIO提供两类函数：
- **无缓冲的输入输出函数**。这些函数直接在内存和文件之间传送数据，没有应用级缓冲。他们对将二进制数据读写到网络和从网络读写二进制数据尤其有用。
- **带缓冲的输入函数**。这些函数允许你高效的从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内，类似于为printf这样的标准I/O函数提供的缓冲区。带缓冲的RIO输入函数是线程安全的，它在同一个描述符上可以被交错地调用。

# 读取文件元数据
应用程序能够通过调用stat和fstat函数，检索到关于文件的信息（也称为文件的**元数据（metadata）**）

```
int stat(const char *filename, struct stat *buf);
int fstat(int fd, struct stat *buf);
返回：成功返回0
```
stat的数据结构：只展示主要的

```
struct stat{
    dev_t st_dev;   //device
    ino_t st_ino;   //inode
    mode_t st_mode; //Protection and file type
    ...
    off_t st_size;  //total size,in bytes
    ...
}
```
**st_size**成员包含了文件的字节数大小；**st_mode**成员则编码了文件访问许可位。


# 共享文件
linux内核用三个相关的数据结构来表示打开的文件：
- 描述符表（descriptor table）。**每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的**。每个打开的文件描述符表项指向文件表的一个表项。
- 文件表（file table）。**打开文件的集合是由一张文件表来表示的，所有的进程共享这张表**。每个文件表的表项组成（针对我们的目的）**包括当前的文件位置（读或写的指针位置）、引用计数（reference count，即当前指向该表项的描述符表项数），以及一个指向v-node表中对应表项的指针**。关闭一个描述符会减少相应的文件表表项中的引用计数。内核不会删除这个文件表表项，直到它的引用计数为零。
- v-node表（v-node table）。同文件表一样，所有的进程共享这张v-node表。每个表项包含stat结构中的大多数信息，包括st_mode和st_size成员。

下面展示了典型的打开文件的内核数据结构。这里例子中**两个描述符引用不同的文件，没有共享**：

![descriptor-table](/Users/liujie/Desktop/gitbook/image/computer/descriptor-table.png)

**多个描述符也可以通过不同的文件表表项来引用同一个文件**。例如，如果以同一个filename调用两次open函数，就会出现这种情况。**关键思想是每个描述符都有它自己的文件位置，所以对不同描述符的读操作可以从文件的不同位置获取数据**。如下图，展示了两个描述符通过两个打开的文件表表项共享同一个磁盘文件，即文件共享。

![descriptor-table-share](/Users/liujie/Desktop/gitbook/image/computer/descriptor-table-share.png)

所以，父子进程共享文件也很容易得出，**调用fork后，子进程有一个父进程描述符表的副本，父子进程共享相同的打开文件集合，因此共享相同的文件位置。但有个重要的结果，在内核删除相应的文件表表项之前，父子进程都必须关闭了它们的描述符**。

![descriptor-table-fork](/Users/liujie/Desktop/gitbook/image/computer/descriptor-table-fork.png)

# IO重定向
举个例子，Linux shell提供了I/O重定向操作符，允许用户将磁盘文件和标准输入输出联系起来，如：

```
linux> ls > foo.txt
```
使得shell加载和执行ls程序，将标准输出重定向到磁盘文件foo.txt。

I/O重定向的一种方式是使用**dup2函数**：

```
int dup2(int oldfd, int newfd);
返回：若成功返回非负的描述符，出错为-1
```
**dup2函数复制描述符表表项oldfd到描述符表表项newfd，覆盖描述符表表项newfd以前的内容。如果newfd已经打开了会先关闭newfd再复制。**

调用dup2(4,1)重定向标准输出之后的内核数据结构：

![IORdirect](/Users/liujie/Desktop/gitbook/image/computer/IORdirect.png)

> 左边和右边的hoinkies：为了区分shell命令中>和<跟其他括号类型的区别，将“>”称为“左hoinkies”，另一个同理。

# 标准I/O库
C语言定义了一组高级输入输出函数，称为标准I/O库，为程序员提供了Unix I/O的较高级别替代。

标准I/O库将一个打开的文件模型化为一个**流**。对于程序员而言，一个流就是一个指向FILE类型的结构的指针。**类型为FILE的流是对文件描述符和流缓冲区的高级抽象。**

流缓存区的目的和RIO读缓冲区的一样：**就是使开销较高的Linux I/O系统调用的数量尽可能的小**。例如，假设我们有个程序反复调用标准I/O的getc函数，每次调用返回文件的下一个字符。当第一次调用getc时，库通过调用一次read函数来填充缓存区，然后将缓冲区中的第一个字节返回给应用程序。只要缓存区还有未读的字节，接下来对getc的调用就能直接从流缓冲区得到服务。

我们现在已经讨论的包：较高级别的RIO和标准I/O都是基于Unix I/O实现的。

![IOFunc](/Users/liujie/Desktop/gitbook/image/computer/IOFunc.png)

**大多数应用程序都应优先使用标准I/O，但由于标准I/O和网络文件的一些相互不兼容的限制，Unix I/O比之标准I/O更适合网络应用程序。**