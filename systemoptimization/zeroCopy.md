# 通过零拷贝进行高效的数据传输

# 概述
> 涉及到计算机操作系统知识：数据写入、存储、读取，即I/O设计原理。

有以下具体的业务场景：

在传统的web应用程序中，应用程序提供了许多页面和静态资源文件，客户访问页面进行加载静态资源的时候，相当于从磁盘读取数据并将完全相同的数据写回响应套接字。这样的一个活动需要相对较少的CPU活动，但效率稍低：**用户将读取文件的中断传递到内核，内核从磁盘读取数据并将其推送到内核用户边界缓冲区给到应用程序，然后应用程序将其推回到内核用户边界对应的套接字缓冲区，最后返回给客户浏览器。这个过程中实际上应用程序充当了一个低效的中介，它将数据从磁盘文件获取并传递到套接字。**

由上可知，数据在内核空间和用户空间之间拷贝，会消耗CPU周期和内存带宽。幸运地是，我们可以通过一种称为“appropriately enough —zero copy”的技术来消除这些多余的拷贝操作。**使用zero-copy请求的应用程序，内核将数据直接从磁盘文件复制到套接字，而无需通过应用程序。零拷贝极大地提高了应用程序性能，并减少了内核和用户模式之间的上下文切换次数（本质上是内核进程和用户进程之间的上下文切换）。**

**Java类库java.nio.channels.FileChannel通过以下transferTo()方法支持Linux和UNIX系统上的zero-copy**。您可以使用该transferTo()方法将字节直接从调用它的通道传输到另一个可写字节通道，而不需要将数据流过应用程序。本文首先演示了通过传统复制语义完成的简单文件传输所产生的开销，然后展示了使用零复制技术如何transferTo()实现更好的性能。

# 具体说明

## 传统的文件复制方式
我们以一个相对简单的Socket连接，将从文件读取数据然后传输到另一个程序的方案举例：

核心逻辑是：读取文件中的字节，并复制到套接字进行发送

```
File.read(fileDesc, buf, len);
Socket.send(socket, buf, len);
```
虽然上面的核心逻辑很简单，但在内部，**复制操作需要在用户模式和内核模式之间进行四次上下文切换，并且在操作完成之前将数据复制四次**。下图显示了数据如何从文件内部移动到套接字：

**数据复制：**

![image](http://note.youdao.com/yws/res/20979/3E15230B8D2E4A50A11715191D17A461)

> DMA copy（直接存储器读取）：是一种快速传送数据的机制。
> CPU copy:

**上下文切换：**

![image](http://note.youdao.com/yws/res/20983/FEDF0A6BE90C479BBFE93ADB0CEB2AE6)

涉及的具体步骤是：
1. read()会发起系统调用导致从用户模式到内核模式的上下文切换。在内部发出sys_read()（或等效的）来从文件中读取数据。第一个复制由直接内存访问（DMA）引擎执行，该引擎从磁盘读取文件内容并将它们存储到内核地址空间缓冲区中。
2. 请求的数据从读缓冲区复制到用户缓冲区，发生第二个复制，然后read()返回调用。从调用返回导致另一个上下文从内核切换回用户模式。现在数据存储在用户地址空间缓冲区中。
3. 该send()系统调用导致从用户模式到内核模式的上下文切换。执行第三个复制，再次将数据放入内核地址空间缓冲区。但是，这一次，数据被放入一个不同的缓冲区，一个与目标套接字相关联的缓冲区。
4. 该send()系统调用返回，创造了第四上下文切换。独立和异步地，当DMA引擎将数据从内核缓冲区传递到协议引擎时，会发生第四个复制。

**使用中间内核缓冲区（而不是将数据直接传输到用户缓冲区）似乎效率低下**。**但是，在流程中引入了中间内核缓冲区以提高性能。使用读取端的中间缓冲区允许内核缓冲区在应用程序未请求与内核缓冲区保持的数据量相同时充当“预读缓存”。当请求的数据量小于内核缓冲区大小时，这显着提高了性能。写入端的中间缓冲区允许写入异步完成**。

不幸的是，**如果请求的数据大小远大于内核缓冲区大小，这种方法本身就会成为性能瓶颈。在最终将数据传送到应用程序之前，数据会在磁盘，内核缓冲区和用户缓冲区之间多次复制。**

零拷贝通过消除这些冗余数据副本来提高性能。

## zero-copy传输数据
如果您重新检查传统方案，您会注意到实际上并不需要第二个和第三个数据副本。应用程序除了缓存数据并将其传输回套接字缓冲区之外什么都不做。相反，数据可以直接从读缓冲区传输到套接字缓冲区。该transferTo()方法可以让您完成此操作。下面是方法transferTo()：

```
public long transferTo(long position, long count, WritableByteChannel target) throws IOException;
```
**该transferTo()方法将数据从文件通道传输到给定的可写字节通道**。在内部，它取决于底层操作系统对零拷贝的支持; 在UNIX和各种版本的Linux中，此调用被路由到sendfile()系统调用，如下所示，它将数据从一个文件描述符传输到另一个文件描述符：（从in_fd文件描述符打开的文件对应offset位置传输count大小的数据给out_fd文件描述符）

```
#sendfile() 系统调用
#include <sys/socket.h>
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```

使用transferTo()方法的数据复制情况：

![image](http://note.youdao.com/yws/res/21031/FDF8D7EC8F6B435B87FF68E310750615)

使用transferTo()方法时的上下文切换：

![image](http://note.youdao.com/yws/res/21034/C17C63A6B17F45F793A914B83B1DF162)

涉及到的步骤是：
1. 该transferTo()方法使文件内容被DMA引擎复制到读缓冲区中。然后，内核将数据复制到与输出套接字关联的内核缓冲区中。
2. 第三个副本发生在DMA引擎将数据从内核套接字缓冲区传递到协议引擎时。

这是一个改进：我们将上下文切换的数量从四个减少到两个，并将数据副本的数量从四个减少到三个（其中只有一个涉及CPU）。但这还没有达到我们零拷贝的目标。如果底层网络接口卡支持收集操作，我们可以进一步减少内核完成的数据复制。在Linux内核2.4及更高版本中，修改了套接字缓冲区描述符以满足此要求。这种方法不仅减少了多个上下文切换，还消除了需要CPU参与的重复数据副本。用户端使用情况仍然相同，但内在函数已更改：
1. 该transferTo()方法使文件内容被DMA引擎复制到内核缓冲区中。
2. 没有数据被复制到套接字缓冲区中。相反，只有具有有关数据位置和长度信息的描述符才会附加到套接字缓冲区。DMA引擎将数据直接从内核缓冲区传递到协议引擎，从而消除了剩余的最终CPU副本。

使用transferTo()和collect操作时的数据复制：

![image](http://note.youdao.com/yws/res/21050/1B7FCCA8732A4A5BBEAED6D97F29CB39)

**transferTo()与从一个通道读取和将相同数据写入另一个通道相比，我们已经证明了使用的性能优势。中间缓冲区副本 - 即使是隐藏在内核中的副本 - 也可能具有可测量的成本。在通道之间进行大量数据复制的应用程序中，零复制技术可以显着提高性能。**

## 构建文件服务器
使用上面的两种方式实践

### 性能参考



# 应用场景

如：Kafka使用了零拷贝进行高效的集群节点分区日志复制。


# 参考
https://developer.ibm.com/articles/j-zerocopy/