# MYSQL基础

# 锁
## 读写锁
共享锁（读锁）：共享的，互不阻塞
排他锁（写锁）：阻塞其他的读锁和写锁

## 锁粒度
### 表锁
- 锁定整张表
- 对表进行写操作时需要先获得写锁，阻塞其他用户对该表的所有读写操作
- 只有不存在写锁时。其他用户才能获得读锁，读锁互补阻塞
- 特定场景中，表锁可以有良好的性能。如READ LOCAL 表锁支持某些类型的并发写操作
- 写锁比读锁优先级更高，因此一个写锁请求可能会插入到读锁队列前面，反之不行
- 存储引擎管理自己的锁机制，但mysql还是会对某些操作进行表锁，如alter table等

### 行级锁
最大程序的支持并发处理，但也带来了最大的锁开销

如InnoDB、XtraDB等存储引擎实现了行级锁

行级锁只在存储引擎层实现，而mysql服务器层没有实现

# 事务
## 基础概念
事务就是一组原子性的SQL查询，或者说一个独立的工作单元

## ACID特性
一个实现了ACID的数据库对比没有实现的数据库需要更强的CPU处理能力，更大的内存，更多的磁盘空间，这就是Mysql的存储引擎架构的优势所在，可以根据业务决定是否需要事务处理
- 原子性（Atomicity）：不可分割的最小工作单元，要么全部成功，要么全部失败回滚
- 一致性（Consistency）：数据库总是从一个一致性的状态转换到另一个一致性的状态
- 隔离性（Isolation）：一般情况（隔离级别不同），一个事务所做的修改在最终提交之前对其他事务不可见
- 持久性（Durablility）：一旦事务提交，则其所做的修改就会永久保存持久化在数据库中

## 隔离级别
- READ UNCOMMITED（未提交读）：事务中的修改，即使没有提交也是对其他事务可见的。事务读取到未提交的数据即脏读（Dirty Read）。这个级别会导致很对问题，且性能不比其他级别好太多，一般很少使用
- READ COMMITED（提交读）：大多数的数据库默认级别（但mysql不是），一个事务从开始到提交之前，所做的修改对其他事务不可见。这个级别也可以叫做不可重复读（弄repeatable read）
- REPEATABLE READ（可重复读）：解决了脏读的问题，也是mysql的默认事务隔离级别，保证了同一个事务中多次读取同样的记录结果是一致的。该级别无法解决幻读，mysql中的存储引擎InnoDB和XtraDB通过MVCC解决了幻读
- SERIALIZABLE（可串行化）：最高的隔离级别，通过强制事务串行执行解决了幻读问题。该级别会在读取的每一行数据加锁，所以可能导致大量的超时和锁争用问题。只有在非常需要保证一致性且不需要并发时才考虑使用

## 死锁
指两个或以上的事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就有可能产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。

为了解决死锁，数据库系统实现了各种死锁检测和死锁超时机制。如InnoDB，将持有最少行排他锁的事务进行回滚，也是相对简单的死锁回滚算法

锁的行为和顺序与存储引擎相关，死锁发生后只有部分或完全回滚其中一个事务才能被打破

## 事务日志
事务日志可以帮助提高事务的效率

使用事务日志，存储引擎修改表时只需要修改其内存拷贝，再把该修改行为记录持久在硬盘的事务日志上，而不用每次都将修改的数据本身持久化到磁盘。

事务日志采用的追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序IO，而不像随机IO需要在磁盘的多个地方移动磁头，所以更快。事务日志持久化之后，内存中被修改的数据在后台可以慢慢的刷回磁盘。目前大多数存储引擎都是这种方式，称之为预写式日志，修改数据需要写两次磁盘。

如果数据写了日志，但是还没有写回磁盘，此时系统崩溃，存储引擎重启式会恢复这部分数据，具体恢复方式根据不同的存储引擎定

## Mysql中的事务
提供两种事务型的存储引擎：InnoDB和NDB Cluster。还有一些第三方存储引擎也支持，如：XtraDB和PBXT等。

**自动提交（AUTOCOMMIT）**：MYSQL默认采用自动提交模式。也就是说，如果不是显式的开始一个事务，则每个查询都被当做一个事务执行提交操作。在当前连接中可以设置AUTOCOMMIT变量来启用或禁用自动提交：

```
SHOW VARIABLES LIKE 'AUTOCOMMIT'; SET AUTOCOMMIT = 1;（1表示启用，0表示禁用）
```
当设置为0，所有的查询都在一个事务内，知道显式的执行COMMIT或ROLLBACK结束这个事务，同时又开始了新事务。

修改AUTOCOMMIT对非事务型的表，如MyISAM或内存表，不会有任何影响

MYSQL可以通过执行SET TRANSACTION INSOLATION LEVEL命令来设置隔离级别，新的隔离级别会在下一个事务开始时生效。可以在配置文件中设置数据库的隔离级别，也可以只改变当前会话的隔离级别：
> SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITED;

**隐式和显式锁定：InnoDB使用的是两阶段锁定协议**。在事务执行过程中，随时都可以锁定，锁只有在执行commit和rollback的时候才会被释放，且所有锁都在同一时刻释放。这些都是隐式锁定。

## 多版本并发控制（MVCC）
MYSQL的大多数的事务型存储引擎实现的都不是简单的行级锁，基于并发考虑一般都实现了MVCC。其他数据库类似oracle、PostgreSQL等也都实现了MVCC，但实现的机制不进相同。

MVCC是行级锁的一个变种，但它在很多情况下避免了加锁操作，所以开销更低。虽然实现机制不同，但基本都实现了非阻塞读，写锁也只锁定必要的行。

MVCC是通过保存数据在某个时间点的快照实现的。也就是说不管需要执行多长时间，每个事务看到的数据是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。

### InnoDB的MVCC
每行记录后面保存两个隐藏的列：**行的创建时间、行的过期/删除时间，保存的非时间，而是系统的版本号**

每开启一个事务，系统版本号都会自动递增，事务开始时候的版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

只兼容在**REPEATABLE READ和READ COMMITED**两个隔离级别下工作。因为READ UNCOMMITED总是读取最新的数据行，而SERIALIZABLE会对所有读取的行加锁

REPEATABLE READ隔离级别下的MVCC工作机制：
- SELECT:会以两个条件检查每行记录：只查找版本早于当前事务版本的数据行（即行的系统版本号小于等于事务的系统版本号），这样可以确保读取的行是在事务开始前存在或被自身修改的；行的删除版本要么未定义，要么大于当前事务版本号，这样可以确保在事务开始前行未被删除
- INSERT：为新插入的每一行保存当前系统版本号作为行版本号
- DELETE：为删除的每一行保存当前版本号作为行删除标识
- UPDATE：为插入一行新纪录，保存当前系统版本号为行版本号，同时保存当前的系统版本号到原来的行作为行删除标识版本

# 存储引擎
大部分情况下，InnoDB都是合适的存储引擎

除非需要用到某些InnoDB没有的特性，且没有其他方式可以替代，否则都应该选择InnoDB。例如全文索引：优先考虑InnoDB+Sphinx而不是MyISAM。
## InnoDB
MYSQL的默认事务型引擎，也是最重要和最广泛的存储引擎

**设计用来处理大量的短期事务（short-lived），短期事务大部分会被正常提交，极少会被回滚。InnoDB性能良好且有自动崩溃恢复特性。**

特性：
- 使用MVCC来支持高并发，实现了四个标准的隔离级别，默认隔离级别是REPEATABLE READ，并且通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁是的InnoDB不仅仅锁定查询涉及的行，还会对索引的间隙进行锁定，防止幻影行的插入。
- InnoDB表是基于聚簇索引建立的。InnoDB的索引结构跟其他的存储引擎有很大不同，聚簇索引对主键查询有很高的性能提升。不过他的二级索引（非主键索引）必须包含主键列，所以主键列很大的话其他的索引也会很大。
- 内部进行了优化，包括磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。
- 通过一些机制和插件可以真正的实现热备份，其他的存储引擎不支持热备份。

## MyISAM
mysql5.1之前的默认存储引擎，提供了全文索引、压缩、空间函数等特性，但不支持事务和行级锁，且崩溃后无法安全恢复。但对于只读数据，或者表比较小、可以忍受修复操作的业务还是可以使用。

### 存储
将表存在两个文件中：数据文件和索引文件，分别以.MYD和.MYI为扩展名。

表可以存储的行记录数受限于可用的磁盘空间或操作系统的单个文件的最大尺寸。

### 特性
- 加锁与并发：对整张表加锁而不是行，读取时会对需要读到的所有表加共享锁，写入时则对表加排他锁。但是在对表有读取查询的同时，也可以往表插入新的记录。
- 修复：可以手工或自动执行检查和修复操作，执行表的修复可能会丢失数据，且该操作时非常慢的
- 索引特性：对于MyISAM表，即使是BLOB和TEXT等长字段，也可以基于其前500个字符创建索引。也支持全文索引，这是一种基于分词创建的索引，可以支持复杂查询。
- 延迟更新索引键：创建MyISAM表时，如果指定了DELAY_KEY_WRITE选项，在每次修改完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有清理缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。

### 优化
压缩表：如果表在创建和导入数据后不需要修改，那么这样的表更适合采用压缩表。使用myisampack对MyISAM表进行压缩，压缩表不能修改，可以极大的减少磁盘占用，因此也可以减少磁盘I/O，从而提升性能，也支持索引，但索引也是只读的。

性能：数据以紧密格式存储。

## 内建的其他存储引擎（有些版本不支持）
### Archive引擎
只支持select和insert，mysql5.1之前也不支持索引

针对高速插入和压缩做了优化的简单引擎（适合日志和数据采集类应用）

### Blackhole引擎
没有实现任何存储机制，丢弃所有插入的数据，不做任何保存。但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者只是简单的记录到日志。

### CSV引擎
将普通的CSV文件作为MYSQL中的表来处理，但不支持索引。可以将Excel等电子表格中的数据存储为CSV文件，然后复制到Mysql数据目录下，就能在Mysql中打开使用。因此CSV引擎可以作为一种数据交换的机制。

### Memory引擎
适用场景：支持快速访问数据，且数据不会被修改，重启后丢失也没关系。Memory表（也叫Heap表）至少比MyISAM快一个数量级，因为所有的数据都保存在内存中，不需要经过磁盘I/O。Memory表的结构在重启后还会保留，但数据会丢失。

### Merge引擎
MyISAM的一个变种，Merge表是由多个MyISAM表合并而来的虚拟表，适用于日志或数据仓库应用，但是引入分区后，该引擎已放弃。