# 高性能索引策略

根据创建索引的数据结构不同，会带来其他的附加作用:主要有以下三点：

- 索引大大减少了服务器需要扫描的数据量
- 帮助服务器避免排序和临时表
- 可以将随机I/O变成顺序I/O

辨证看待
- 索引并不是最好的解决方案
- 只有当索引帮助存储引擎快速找到记录等带来的好处大于其带来的额外开销外，索引才是有效的
- 对于非常小的表，大部分情况下简单的全局扫描更高效
- 对于特大型的表，建立和使用索引的代价也会随之增长，这种情况下需要一种技术可以直接区分出查询需要的一组数据，而不是一条条的记录匹配，如使用分区技术等。

## 索引的类型
在MYSQL中，索引是存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准：不同的存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层实现也可能不同。

### B-Tree索引
大多数MYSQL存储引擎支持这种索引结构，一般我们说的索引都是B-Tree索引，但不同的存储引擎实现会有不同，如NDB集群存储引擎内部实际用到的是T-Tree结构存储这种索引，InnoDB使用的是B+Tree。

![wechatimg1.jpeg](http://note.youdao.com/yws/res/8557/WEBRESOURCE649e002993471c145fc52097323d11cf)

**B+Tree:每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。**

存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣。如MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式存储，又例如MyISAM通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。

B-Tree对多个值（多列索引）进行排序的依据是建表语句中定义索引时列的顺序，适用于全键值、键值范围和键前缀查找（键前缀查找只适用于根据最左前缀的查找）。
### Hash索引
**基于哈希表实现，只能精准匹配索引所有列的查询才有用。**

对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同的键值行计算出来的哈希码也是不同的。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一哈希条目中。

#### 限制
- 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行，但访问内存中的行速度很快，所以这一点对内存的影响也并不明显。
- 哈希索引不支持部分索引列匹配查询，因为哈希索引始终是以列中的所有索引列来计算索引值的。
- 索引数据并不是按索引值顺序存储的，所以不能排序。
- 只接受等值比较查询，不支持任何的范围查询。
- 访问哈希索引非常快，除非有很多相同哈希值的列，当出现哈希冲突时，存储引擎会遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。
- 哈希值冲突很多的话会造成更大的索引维护操作代价。

#### InnoDB的使用Hash索引进行优化查找
InnoDB引擎有一个特殊的功能叫做“自适应哈希索引（adaptive hash index）”。当InnoDB注意到某些索引值被使用得非常频繁时，他会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，如快速哈希查找。

### 空间数据索引（R-Tree）
MyISAM表支持空间索引，可以用作地址数据存储。但MYSQL的GIS支持并不完善，所以基本不会使用这个特性。

### 全文索引
全文索引是一种特殊类型索引，他查找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其他索引的匹配方式完全不一样。它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。

### 其他索引类型

# 高性能索引策略
正确的创建和使用索引是实现高性能查询的基础。
## 独立的列
当一些查询不当地使用索引，会使得MYSQL无法使用已有的索引。**如果查询中的列不是独立的，则MYSQL就不会使用索引。**

独立的列：指的是索引列不能使表达式的一部分，也不能是函数的参数。

## 前缀索引和索引的选择性
有时候需要索引的字段很长，这会让索引变得大且慢。一个策略是使用模拟哈希索引。但有时候这样还不够，还可以怎么做？

解决办法：索引字段开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但是这样也会降低索引的选择性。

> 索引的选择性：指不重复的索引值（也称为基数）和数据表的记录总数（#T）的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以在查询时过滤更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

所以我们要选择足够长的前缀以保证较高的选择性，同时又不能太长以便于节约空间。

创建前缀索引：

```
mysql>ALTER TABLE 表名 ADD KEY (列名(前缀长度));
```

前缀索引的缺点：无法做order by 和 group by，也无法使用前缀索引做覆盖扫描。

## 多列索引
我们常见的创建索引的误区：
- 为每个列创建独立的索引；
- 按照错误的顺序创建多列索引。

Mysql5.0之后有一种**索引合并策略**，用来优化复杂查询。但也侧面反映了表上的索引建的很糟糕：
- 当出现服务器对多个索引做相交操作时（通常有多个AND条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
- 当服务器需要对多个索引做联合操作时（通常有多个OR条件），通常需要耗费大量的CPU和内存资源在算法的缓存、排序和合并操作上。

## 选择合适的索引列顺序
什么样的索引列顺序是最合适的？

正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。（像B-Tree顺序地存储数据）

如何选择索引的列顺序有一个经验法则：将选择性高的列放到索引最前列。

## 聚簇索引
聚簇索引并不是一种索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。

当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同事把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引（覆盖索引可以模拟多个聚簇索引的情况）。

因为是存储引擎负责实现索引，所以不是所有的存储引擎都支持聚簇索引。这里主要分析InnoDB，但原理是通用的。

**那么聚簇索引中的记录是如何存放的？** 叶子页包含了行的全部数据，但是节点页只包含了索引列。InnoDB将通过主键聚集数据，如果没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录，包含相邻键值的页面可能会相距甚远。

聚集的数据有一些中重要的优点：（局部化原理）
- 可以把相关数据保存在一起。例如实现电子邮箱时，使用用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有聚簇索引，则每封邮件都可能导致一次磁盘I/O。
- 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。
- 使用覆盖索引扫描的查询可以直接页节点中的主键值。

同时，聚簇索引也有以下缺点：
- 聚簇数据最大限度地提高了I/O密集型应用的性能，但如果数据全部放在内存中，则访问吮吸就没那么重要了，聚簇索引的优势也不在了；
- 插入速度严重依赖于插入顺序。按照主键的插入顺序是加载数据到InnoDB表中速度最快的方式。
- 更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。
- 基于聚簇索引列的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂（page split）”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作，页分裂会导致表占用更多的磁盘空间。
- 聚簇索引可能会导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂操作导致数据存储不连续的时候。
- 二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。
- 二级索引访问需要两次索引查找，而不是一次。

同时，在InnoDB中，使用UUID作为主键而不是顺序整数自增作为主键会存在以下缺点：
- 写入的目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘中读取目标页到内存中。这将导致大量的随机I/O。
- 因为写入时乱序的，InnoDB不得不频繁的做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。
- 由于频繁的页分裂，页会变得稀疏并被不规则地填充，所以最终数据会有碎片。

**并且，在把这些随机值载入到聚簇索引以后，也许需要做一次OPTIMIZE TABLE来重建表并优化页的填充。**

所以，**使用InnoDB时应该尽可能地按主键顺序插入数据，并且尽可能地使用单调增加的聚簇键的值来插入新的行。**

> 二级索引：即非聚簇索引，innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。

**那么顺序主键什么时候会造成更坏的结果？**
> 对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用。主键的上界会成为“热点”。因为所有的插入都发生在这里，所以并发插入可能会导致间隙锁竞争。另一个热点可能是AUTO_INCREMENT锁机制；如果遇到这个问题，则可能需要重新设计表或者应用，或者更改innodb_automic_lock_mode配置。

## 覆盖索引
通常我们都会根据查询的where条件来创建合适的索引，不过这只是索引优化的一个方面。设计优秀的索引应该考虑到整个查询，而不单单是WHERE条件部分。

索引确实是一种查找数据的高效方式，但是MySQL也可以使用索引来直接获取列的数据，这样就不再需要读取数据行。如果索引的叶子节点中已经包含要查询的数据，那么还有什么必要再回表查询呢？如果一个索引包含（或者说覆盖）所有需要查询的字段的值，那么我们就称之为**“覆盖索引”**。

覆盖索引能够极大的提升性能。如果查询只需要扫描索引而无须回表，会带来多少好处：
- 索引条目通常远小于数据行大小，所以如果只需要读取索引，那么Mysql就会极大地减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花在数据拷贝上。覆盖索引对于I/O密集型的应用也有帮助，因为索引比数据更小，更容易全部放入内存中。
- 因为索引是按照列值顺序存储的（至少单页上是这样），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行的数据I/O要少得多。
- 一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。这可能会导致严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。
- **由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。** InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。

**不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以Mysql中只能使用B-Tree索引做覆盖索引。**

> 所以查询目标列比起全表全部列查询，能更好的使用覆盖索引提升性能。

## 使用索引扫描来做排序
Mysql有两种方式可以生成有序的结果：
- 通过排序操作；
- 按索引顺序扫描。

如果EXPLAIN出来的type列的值为“index”，则说明MySQL使用了索引扫描来做排序（与Extra列的“Using index”不同）

扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在I/O密集型的工作负载时。

只有当索引的列顺序和order by子句的顺序完全一致，并且所有列的排序顺序方向都一样时，Mysql才能够使用索引来对结果做排序。

## 压缩（前缀压缩）索引
MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能够极大的提高性能。

MyISAM压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。
> 例如，索引块的第一个值是“perform”，第二个值是“performance”，那么第二个值的前缀压缩后存储的是类似“7，ance”这样的形式。

压缩块使用更少的空间，代价是某些操作可能更慢。因为每个值的压缩前缀都依赖前面的值，所以MyISAM查找时无法在索引块使用二分查找而只能从头开始扫描。

测试表明，对于CPU密集型应用，因为扫描需要随机查找，压缩索引使得MyISAM在索引查找上慢上好几倍。
## 冗余和重复索引
Mysql允许在相同列上创建多个索引。**重复索引是指在相同列上按照相同的顺序创建的相同类型的索引。应该避免这样的索引创建，发现以后应立即删除。**

冗余索引和重复索引有一些不同：
- 如果创建了索引（A,B），再创建索引（A）就是冗余索引，因为这只是前一个索引的前缀索引。因此索引（A，B）也可以当做索引（A）来使用（这种冗余只是针对B-Tree索引说的）
- 但是如果再创建了索引（B，A），则不是冗余索引，索引（B）也不是，因为B不是索引（A，B）的最左前缀列。

## 未使用的索引
除了冗余索引和重复索引，可能还会有服务器永远用不到的索引，这样的索引完全是累赘，需要删除。

有两个工具可以帮助定位未使用的索引：
1. 在Percona Server或者MariaDB中先打开userstates服务器变量，然后让服务器运行一段时间，然后查询INFORMATION_SCHEMA.INDEX_STATISTICS就能查到每个索引的使用频率；
2. 还可以使用Percona Toolkit中的pt-index-usage，该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操作，打印关于索引和查询的报告。

## 索引和锁
**索引可以让查询锁定更少的行。** 

InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。

# 维护索引和表
维护表有三个目的：
- 找到并修复损坏的表
- 维护准确的索引统计信息
- 减少碎片

## 找到并修复损坏的表
损坏的索引会导致查询返回错误的结果或者莫须有的主键冲突等问题，严重时甚至还会导致数据库的崩溃。

如果遇到了古怪的问题---例如一些不应该发生的错误---可以尝试运行**CHECK TABLE**来检查是否发生了表损坏。CHECK TABLE 通常能够找出大多数的表和索引的错误。

可以使用**REPAIR TABLE** 命令来修复损坏的表，但同样不是所有的存储引擎都支持该命令。要是存储引擎不支持，也可通过一个不错任何操作（no-op）的ALTER操作来重建表，例如修改表的存储引擎为当前的引擎。如：

```
mysql> ALTER TABLE innodb_tbl ENGINE=INNODB;
```
如果是InnoDB引擎的表出现了损坏，那么一定是发生了严重的错误，需要立刻调查原因，InnoDB的设计保证了它并不容易被损坏。如果发生了，要么是数据库的硬件问题，例如内存或磁盘问题，要么是数据库管理员的错误例如在MySQL外部操作了数据文件。

## 更新索引统计信息
**MySQL的查询优化器会通过两个API来了解存储引擎的索引值的分布信息，以决定如何使用索引。** 
- records_in_range()，通过向存储引擎传入两个边界值获取在这个范围大概有多少条记录。对于某些存储引擎，该接口返回精确值，例如MyISAM；但对于另一些存储引擎则是一个估算值，例如InnoDB。
- info()，该接口返回各种类型的数据，包括索引的基数（每个键值有多少条记录）

如果存储引擎向优化器提供的扫描行数信息是不准确的数据，或者执行计划本身太复杂以致无法准确地获取各个阶段匹配的行数，那么优化器会使用索引统计信息来估算扫描行数。

MySQL优化器使用的是基于成本的模型，而衡量成本的主要指标就是一个查询需要扫描多少行。如果表没有统计信息，或者统计信息不准确，优化器就有可能做出错误的决定。可以通过运行ANALYZE TABLE来重新生成统计信息解决这个问题。

## 减少索引和数据碎片
**B-Tree索引可能会碎片化，这会降低查询的效率。碎片化的索引可能会以很差或者无序的方式存储在磁盘上。** 根据设计，B-Tree需要随机磁盘访问才能定位到叶子页，所以随机访问是不可避免的。然而，如果叶子页在物理分布上是顺序且紧密的，那么查询的性能就会更好。否则对于范围查询、索引覆盖查询等操作来说速度可能会降低很多倍，对于索引覆盖扫描这一点更加明显。

表的数据存储也可能碎片化，然后数据存储的碎片化比索引更加复杂。有三种类型的数据碎片：
- 行碎片（Row fragmentation）：指的是数据行被存储在多个地方的多个片段中。即使查询只从索引中访问一行记录，行碎片也会导致性能下降。
- 行间碎片（Intra-row fragmentation）：行间碎片指的是逻辑上顺序的页，或者行在磁盘上不是顺序存储的。行间碎片对于诸如全表扫描和聚簇索引扫描之类的操作有很大的影响，因为这些操作原本能够从磁盘上顺序存储的数据中收益。
- 剩余空间碎片（Free space fragmentation）：指的是数据页中有大量的空余空间。这会导致服务器读取大量不需要的数据，从而造成浪费。

对于MyISAM来说，这三类碎片化都可能发生。但InnoDB不会出现短小的行碎片；InnoDB会移动短小的行并重写到一个片段中。

可以通过执行OPTIMIZE TABLE 或者导出再导入的方式来重新整理数据。对于不支持OPTIMIZE TABLE的存储引擎，可以通过一个不做任何操作的ALTER TABLE操作来重建表，如讲表的存储引擎修改为当前的引擎。

# 总结
在MySQL中，大多数情况使用B-Tree索引。其他类型的索引大多只适用于特殊的目的。

在选择和编写利用这些索引查询时，有三个原则：
- 单行访问时很慢的。特别是咋机械硬盘中（SSD的随机I/O更快）。虽好读取的块中能包含尽可能多的所需要的行。使用索引可以创建位置引用以提升效率。
- 按顺序访问范围数据时很快的，有两个原因：1、顺序I/O不需要多次磁盘寻道，所以比随机I/O要快得多；2、如果服务器能够按需要的顺序读取数据，那么久不需要额外的排序操作。
- 索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，俺么存储引擎就不需要再回表查找行。这避免了大量的单行访问。

如何判断一个系统创建的索引是合理的呢？

一般来说，我们按响应时间来对查询进行分析。找出那些消耗最长时间的查询或者那些给服务器带来最大压力的查询（基准测试），然后检查这些查询的schema、SQL和索引结构，判断是否有查询扫描了太多行，是否做了很多额外的排序或者使用了临时表，是否使用随机I/O访问数据，或者是有太多回表查询那些不在索引中的列的操作。