# 查询优化

# 查询执行的基础
当希望MySQL能够以更高的性能查询运行查询时，最好的办法就是弄清楚MySQL是如何优化和执行查询的。

我们向MySQL发送一个请求的时候，MySQL到底做了什么：

![image](http://note.youdao.com/yws/res/142521/DA39CCF6A2754192961AC4C55FF1E7A9)

1. 客户端发送一条查询给服务器；
2. 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段；
3. 服务端进行SQL解析、预处理，再由优化器生成对应的执行计划；
4. MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；
5. 将结果返回给客户端。

上诉步骤每一步都很复杂，将分别讨论。

## MySQL客户端/服务端通信协议
**MySQL客户端和服务端之间的通讯协议是“半双工”的，即在任何一个时刻，要么是有服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。**

这种协议让MySQL通信简单快速，但是也从很多地方限制了MySQL：**一个明显的限制就是，意味着没办法进行流量控制。一旦一端开始发生消息，另一点要接收完整个消息才能响应它。**

客户端用一个单独的数据包将查询传送给服务器。这也是为什么当查询的语句很长的时候，参数max_allowed_package就特别重要了。一旦客户端发送了请求，他能做的就是等待结果。相反地，服务器响应客户端的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地值取前面几条结果，所以这也是查询一定要加上LIMIT限制的原因。

多数连接MySQL的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。MySQL通常需要等所有数据都发送给客户端才能释放这条查询所占用的资源，所以接收全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束。早点释放相应的资源。但是如果需要返回一个很大的结果集的时候，这样做并不好，因为库函数会花很多时间和内存来存储所有的结果集。

### 查询状态
**对于一个MySQL连接，或者说是一个线程，任何时候都有一个状态，该状态表示了MySQL当前正在做什么。** **有很多种方式能查看当前的状态，最简单的是使用show full processlist命令。 **

状态解释：
- Sleep：线程正在等待客户端发送新的请求。
- Query：线程正在执行查询或者正在将结果发送给客户端。
- Locked：在MySQL服务层，该线程正在等待锁。在存储引擎级别实现的锁，例如InnoDB的行锁，并不会体现在线程状态中。
- Analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划。
- Copying to tmp table [on disk]：线程正在执行查询，并将其结果集都复制到一个临时表中，这种状态一般要么是在做group by 操作，要么是在做文件排序操作，或者是UNION操作。如果这个状态后面还有“on disk”标记，那表示MySQL正在将一个内存临时表放到磁盘上。
- Sorting result：线程正在对结果集进行排序。
- Sending data：表示多种情况：线程可能在多个状态之间传送数据，或者生成结果集，或者在向客户端返回数据。

## 查询缓存（Query Cache）
**在解析一个查询语句之前，如果查询缓存是打开的，那么MySQL会优先检查这个查询是否命中查询缓存中的数据。这个查询是通过一个对大小写敏感的哈希查找实现的。** 查询和缓存中的查询即使只有一个字节不同，那么也不会匹配缓存结果，这种情况下查询会进入下一阶段处理。

完全相同的查询在重复执行的时候，查询缓存可以立即返回结果，而无须在数据库中重新执行一次，根据我们的经验，在高并发压力环境中查询缓存会导致系统性能的下降，甚至僵死。如果一定要使用查询缓存，那么不要设置太大的内存，而且只有在明确收益的时候才使用。

查询缓存对于读和写操作都有额外的消耗：
- 读查询在开始之前必须先检查是否命中缓存；
- 如果这个读查询可被缓存，那么当完成执行后哦，MySQL若发现查询缓存中没有这个查询，会将其结果存入查询缓存，这会带来额外的系统消耗；
- 这对写操作也会有影响，因为当向某个表写入数据的时候，MySQL必须将对应表的所有缓存都设置失效。如果查询缓存非常大或者碎片很多，这个操作就会带来很大的系统消耗。

如果查询缓存使用了很大的内存，缓存失效操作就会成为一个非常严重的问题瓶颈。如果缓存中存放了大量的查询结果，那么缓存失效操作时整个系统都可能僵死一会儿。因为这个操作是靠一个全局锁操作保护的，所有需要做该操作的查询都要等待这个锁（无论是检测是否命中、还是缓存失效检测都需要等待这个全局锁）。

查询缓存服务器配置参数：
- query_cache_type：是否打开查询缓存。可以设置成OFF、ON和DEMAND。DEMAND表示只有在查询语句中明确写明SQL_CACHE的语句才会放入缓存。
- query_cache_size：查询缓存使用的总内存空间，单位是字节。这个值必须是1024的整数倍，否则MySQL实际分配的数据会和你指定的略有不同。
- query_cache_min_res_unit：查询缓存中分配内存块时的最小单位。**选择合适的值可以帮助减少由内存碎片导致的内存空间浪费，太小会使浪费空间更少但会导致更频繁的内存块申请分配操作，值太大会浪费更多空间。**
- query_cache_limit：MySQL能够缓存的最大查询结果。如果查询结果大于这个值，则不会被缓存。
- query_cache_wlock_invalidate：如果某个数据被其他的连接锁住，是否仍然从查询缓存中返回。默认OFF。

对于写密集的应用来说，直接禁用查询缓存可能会提高系统的性能。因为对互斥信号量的竞争没有事直接关闭查询缓存对读密集型应用也会有好处。所以希望提高系统的并发，需要对比开关前后的数据库性能差异。

## 查询优化处理
**查询的生命周期的下一步是将一个SQL转换成一个执行计划，MySQL载根据这个执行计划和存储引擎进行交互。这包括多个子阶段：解析SQL、预处理、优化SQL执行计划。**

这个过程中任何错误都会终止查询。

### 语法解析器和预处理
MySQL通过关键字将SQL语句进行解析，并生成一棵对应的“解析树”。MySQL解析器将使用MySQL语法规则验证和解析查询。例如：验证是否使用错误的关键字、使用关键字的顺序是否正确等，再或者它还会验证引号是否能前后正确匹配。

预处理器则根据一些MySQL规则进行及你不的检查解析树是否合法，例如：检查数据表和数据列是否存在，还会解析名字和别名，看看是否存在歧义。

下一步是预处理器会验证权限，这通常很快。

### 查询优化器
语法树合法性被验证，接下来由优化器将其转化成执行计划。一条查询语句可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。

MySQL使用基于成本的优化器，它尝试是预测一个查询使用某种执行计划时的成本，并选择其中成本最小的一个。最初，成本的最小单位是随机读取一个4k数据页的成本，后来变得更复杂。我们可以通过查询当前会话的Last_query_cost的值来得知MySQL计算的当前查询的成本：

有很多种原因会导致MySQL优化器选择错误的执行计划：
- 统计信息不准确。MySQL优化器依赖于存储引擎提供的统计信息来评估成本，信息不准会带来执行偏差。如InnoDB因为其MVCC的架构，并不能维护一个数据表的行数的精确统计信息；
- 执行计划中的成本估算不等同于实际执行的成本。
- MySQL的最优是基于成本模型的最优执行计划，与预想的坑不一样。
- MySQL从不考虑并发执行的查询，这可能会影响到当前查询的速度。
- MySQL也并不是任何时候都是基于成本的优化，优势也会基于固定的规则。


MySQL的查询优化器是一个非常复杂的部件，它使用讴歌了很多优化策略来生成一个最优的执行计划。优化策略可以分为：
- 静态优化：可以直接对解析树进行分析，并完成优化。例如，优化器可以通过一些简单的代数变换将where条件转换成另一种等价形式。静态优化在第一次完成后就一直有效，即使使用不同的参数重复执行查询也不会发生变化，可以认为这是一种“编译时优化”。
- 动态优化：动态优化和查询的上下文有关，也可能和很多其他因素有关，例如where条件中的取值、索引中条目对于的数据行数等。这需要在每次查询的时候都重新评估，所以是“运行时优化”。

MySQL能够处理的优化类型：
- 重新定义关联表的顺序
- 将外链接转化成内连接
- 使用等价变换规则
- 优化COUNT()、MIN()和MAX()
- 预估并转化为常数表达式
- 覆盖索引扫描
- 子查询优化
- 提前终止查询
- 等值传播
- 列表IN()的比较

### 数据和索引的统计信息
统计信息由存储引擎实现，不同的存储引擎可能会存储不同的统计信息。某些引擎则跟版本没有存储任何统计信息。

因为服务器层没有任何统计信息，所以MySQL查询优化器在生成查询的执行计划时，需要向存储引擎获取相应的统计信息。存储引擎则提供给优化器对应的统计信息，包括：
- 每个表或索引有多少个页面；
- 每个表的每个索引的基数是多少；
- 数据行和索引长度；
- 索引的分布信息等。

### MySQL如何执行关联查询

### 执行计划
和其他关系数据库不同，MySQL不会生成查询字节码来执行查询。MySQL生成查询的一棵指令树，然后通过存储引擎执行完成这棵指令树并返回结果。最终的执行计划包含了重构查询的全部信息。如果对某个查询执行EXPLAIN EXTENDED后，再执行SHOW WARNINGS，就可以看到重构出的查询。

### 关联查询优化器

### 排序优化
无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能地避免排序或者尽可能避免对大量数据进行排序。

MySQL执行排序时，当不能使用索引生成排序结果的时候，MySQL需要自己进行排序，如果数据量小则在内存中进行，如果数据量大则需要使用磁盘，不过MySQL将这个过程统一称为**文件排序（filesort）**，即使完全是内存排序不需要任何磁盘文件时也是如此。

**如果需要排序的数据量小于“排序缓冲区”，MySQL使用内存进行“快速排序”操作。如果内存不够排序，那么MySQL会先将数据分块，对每个独立的块使用“快速排序”进行排序，并将各个块的排序结果存放在磁盘上，然后将各个排好序的块进行合并，最后返回排序结果。**

MySQL有如下两种排序算法：
- 两次传输排序（旧版本）：读取行指针和需要排序的字段，对其进行排序，然后根据排序结果读取所需要的数据行。这需要两次数据传输，即需要从数据表中读取两次数据，第二次读取数据的时候，因为是读取排序列进行排序后的所有记录，这会产生大量的随机I/O，所以成本很高。
- 单次传输排序（新版本）：限度去查询所有需要的列，然后再根据给定列进行排序，最后直接返回排序结果，不需要两次传输，对于I/O密集型的应用效率提高了很多。

## 查询执行引擎
**在解析和优化阶段，MySQL将生成查询对应的执行计划，MySQL的查询执行引擎则根据这个执行计划来完成整个查询。** 这里执行计划是一个数据结构，而不是其他关系型数据库那样生成的字节码。

## 返回结果给客户端
MySQL将结果集返回给客户端是一个增量、逐步返回的过程。例如，一旦服务器处理完最后一个关联表，开始生成第一条结果时，MySQL就可以开始向客户端逐步返回结果集了。

这样有两个好处：
- 服务器端无须存储太多的结果，也就不会因为要返回太多结果而消耗太多内存；
- 这样处理客户端也能第一时间获得返回的结果。

结果集中的每一行都会以一个满足MySQL客户端/服务器通信协议的封包发送，再通过TCP协议进行传输，在TCP传输过程中，可能对MySQL的封包进行缓存然后批量传输。